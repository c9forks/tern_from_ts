{
  "Promise": {
    "!type": "fn(callback: fn(resolve: fn(thenable: ?), reject: fn(error: ?)))",
    "try": "fn(fn: fn(), args?: [?], ctx?: ?) -> ?",
    "attempt": "fn(fn: fn(), args?: [?], ctx?: ?) -> ?",
    "method": "fn(fn: Function) -> Function",
    "resolve": "fn() -> ?",
    "reject": "fn(reason: ?) -> ?",
    "defer": "fn() -> ?",
    "cast": "fn(value: ?) -> ?",
    "bind": "fn(thisArg: ?) -> ?",
    "is": "fn(value: ?) -> bool",
    "longStackTraces": "fn()",
    "delay": "fn(value: ?, ms: number) -> ?",
    "promisify": "fn(nodeFunction: Function, receiver?: ?) -> Function",
    "promisifyAll": "fn(target: Object) -> Object",
    "coroutine": "fn(generatorFunction: Function) -> Function",
    "spawn": "fn(generatorFunction: Function) -> ?",
    "noConflict": "fn() -> Promise",
    "onPossiblyUnhandledRejection": "fn(handler: fn(reason: ?))",
    "all": "fn(values: ?) -> ?",
    "props": "fn(object: ?) -> ?",
    "settle": "fn(values: ?) -> ?",
    "any": "fn(values: ?) -> ?",
    "race": "fn(values: ?) -> ?",
    "some": "fn(values: ?, count: number) -> ?",
    "join": "fn(values: [?]) -> ?",
    "map": "fn(values: ?, mapper: fn(item: R, index: number, arrayLength: number)) -> ?",
    "reduce": "fn(values: ?, reducer: fn(total: U, current: R, index: number, arrayLength: number), initialValue?: U) -> ?",
    "filter": "fn(values: ?, filterer: fn(item: R, index: number, arrayLength: number)) -> ?",
    "prototype": {
      "then": "fn(onFulfill: fn(value: R), onReject: fn(error: ?), onProgress?: fn(note: ?)) -> ?",
      "catch": "fn(onReject?: fn(error: ?)) -> ?",
      "caught": "fn(onReject?: fn(error: ?)) -> ?",
      "error": "fn(onReject: fn(reason: ?)) -> ?",
      "finally": "fn(handler: fn()) -> ?",
      "lastly": "fn(handler: fn()) -> ?",
      "bind": "fn(thisArg: ?) -> ?",
      "done": "fn(onFulfilled: fn(value: R), onRejected: fn(error: ?), onProgress?: fn(note: ?))",
      "tap": "fn(onFulFill: fn(value: R)) -> ?",
      "progressed": "fn(handler: fn(note: ?)) -> ?",
      "delay": "fn(ms: number) -> ?",
      "timeout": "fn(ms: number, message?: string) -> ?",
      "nodeify": "fn(callback: fn(err: ?, value?: R)) -> ?",
      "cancellable": "fn() -> ?",
      "cancel": "fn() -> ?",
      "fork": "fn(onFulfilled: fn(value: R), onRejected: fn(error: ?), onProgress?: fn(note: ?)) -> ?",
      "uncancellable": "fn() -> ?",
      "isCancellable": "fn() -> bool",
      "isFulfilled": "fn() -> bool",
      "isRejected": "fn() -> bool",
      "isPending": "fn() -> bool",
      "isResolved": "fn() -> bool",
      "value": "fn() -> R",
      "reason": "fn() -> ?",
      "inspect": "fn() -> ?",
      "call": "fn(propertyName: string, args: [?]) -> ?",
      "return": "fn() -> ?",
      "thenReturn": "fn() -> ?",
      "throw": "fn(reason: Error) -> ?",
      "thenThrow": "fn(reason: Error) -> ?",
      "toJSON": "fn() -> Object",
      "spread": "fn(onFulfill: Function, onReject?: fn(reason: ?)) -> ?",
      "all": "fn() -> ?",
      "props": "fn() -> ?",
      "settle": "fn() -> ?",
      "any": "fn() -> ?",
      "some": "fn(count: number) -> ?",
      "race": "fn() -> ?",
      "map": "fn(mapper: fn(item: Q, index: number, arrayLength: number)) -> ?",
      "reduce": "fn(reducer: fn(memo: U, item: Q, index: number, arrayLength: number), initialValue?: U) -> ?",
      "filter": "fn(filterer: fn(item: U, index: number, arrayLength: number)) -> ?"
    },
    "RangeError": {
      "!type": "fn() -> RangeError"
    },
    "CancellationError": {
      "!type": "fn() -> CancellationError"
    },
    "TimeoutError": {
      "!type": "fn() -> TimeoutError"
    },
    "TypeError": {
      "!type": "fn() -> TypeError"
    },
    "RejectionError": {
      "!type": "fn() -> RejectionError"
    },
    "OperationalError": {
      "!type": "fn() -> OperationalError"
    },
    "Thenable": {
      "then": "fn(onFulfilled: fn(value: R), onRejected: fn(error: ?)) -> ?"
    },
    "Resolver": {
      "promise": "?",
      "resolve": "fn(value: R)",
      "reject": "fn(reason: ?)",
      "progress": "fn(value: ?)",
      "callback": "fn(err: ?, value: R, values: [R])"
    },
    "Inspection": {
      "isFulfilled": "fn() -> bool",
      "isRejected": "fn() -> bool",
      "isPending": "fn() -> bool",
      "value": "fn() -> R",
      "reason": "fn() -> ?"
    },
    "setScheduler": "fn(scheduler: fn(callback: fn(args: [?])))"
  },
  "'bluebird'": "Promise",
  "!name": "bluebird.d.ts"
}
