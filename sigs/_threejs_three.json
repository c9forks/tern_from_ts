{
  "WebGLRenderingContext": {},
  "THREE": {
    "REVISION": "string",
    "MOUSE": "number",
    "LEFT": "MOUSE",
    "MIDDLE": "MOUSE",
    "RIGHT": "MOUSE",
    "CullFace": "number",
    "CullFaceNone": "CullFace",
    "CullFaceBack": "CullFace",
    "CullFaceFront": "CullFace",
    "CullFaceFrontBack": "CullFace",
    "FrontFaceDirection": "number",
    "FrontFaceDirectionCW": "FrontFaceDirection",
    "FrontFaceDirectionCCW": "FrontFaceDirection",
    "ShadowMapType": "number",
    "BasicShadowMap": "ShadowMapType",
    "PCFShadowMap": "ShadowMapType",
    "PCFSoftShadowMap": "ShadowMapType",
    "Side": "number",
    "FrontSide": "Side",
    "BackSide": "Side",
    "DoubleSide": "Side",
    "Shading": "number",
    "NoShading": "Shading",
    "FlatShading": "Shading",
    "SmoothShading": "Shading",
    "Colors": "number",
    "NoColors": "Colors",
    "FaceColors": "Colors",
    "VertexColors": "Colors",
    "Blending": "number",
    "NoBlending": "Blending",
    "NormalBlending": "Blending",
    "AdditiveBlending": "Blending",
    "SubtractiveBlending": "Blending",
    "MultiplyBlending": "Blending",
    "CustomBlending": "Blending",
    "BlendingEquation": "number",
    "AddEquation": "BlendingEquation",
    "SubtractEquation": "BlendingEquation",
    "ReverseSubtractEquation": "BlendingEquation",
    "MinEquation": "BlendingEquation",
    "MaxEquation": "BlendingEquation",
    "BlendingDstFactor": "number",
    "ZeroFactor": "BlendingDstFactor",
    "OneFactor": "BlendingDstFactor",
    "SrcColorFactor": "BlendingDstFactor",
    "OneMinusSrcColorFactor": "BlendingDstFactor",
    "SrcAlphaFactor": "BlendingDstFactor",
    "OneMinusSrcAlphaFactor": "BlendingDstFactor",
    "DstAlphaFactor": "BlendingDstFactor",
    "OneMinusDstAlphaFactor": "BlendingDstFactor",
    "BlendingSrcFactor": "number",
    "DstColorFactor": "BlendingSrcFactor",
    "OneMinusDstColorFactor": "BlendingSrcFactor",
    "SrcAlphaSaturateFactor": "BlendingSrcFactor",
    "Combine": "number",
    "MultiplyOperation": "Combine",
    "MixOperation": "Combine",
    "AddOperation": "Combine",
    "Mapping": "number",
    "UVMapping": "Mapping",
    "CubeReflectionMapping": "Mapping",
    "CubeRefractionMapping": "Mapping",
    "EquirectangularReflectionMapping": "Mapping",
    "EquirectangularRefractionMapping": "Mapping",
    "SphericalReflectionMapping": "Mapping",
    "Wrapping": "number",
    "RepeatWrapping": "Wrapping",
    "ClampToEdgeWrapping": "Wrapping",
    "MirroredRepeatWrapping": "Wrapping",
    "TextureFilter": "number",
    "NearestFilter": "TextureFilter",
    "NearestMipMapNearestFilter": "TextureFilter",
    "NearestMipMapLinearFilter": "TextureFilter",
    "LinearFilter": "TextureFilter",
    "LinearMipMapNearestFilter": "TextureFilter",
    "LinearMipMapLinearFilter": "TextureFilter",
    "TextureDataType": "number",
    "UnsignedByteType": "TextureDataType",
    "ByteType": "TextureDataType",
    "ShortType": "TextureDataType",
    "UnsignedShortType": "TextureDataType",
    "IntType": "TextureDataType",
    "UnsignedIntType": "TextureDataType",
    "FloatType": "TextureDataType",
    "PixelType": "number",
    "UnsignedShort4444Type": "PixelType",
    "UnsignedShort5551Type": "PixelType",
    "UnsignedShort565Type": "PixelType",
    "PixelFormat": "number",
    "AlphaFormat": "PixelFormat",
    "RGBFormat": "PixelFormat",
    "RGBAFormat": "PixelFormat",
    "LuminanceFormat": "PixelFormat",
    "LuminanceAlphaFormat": "PixelFormat",
    "RGBEFormat": "PixelFormat",
    "CompressedPixelFormat": "number",
    "RGB_S3TC_DXT1_Format": "CompressedPixelFormat",
    "RGBA_S3TC_DXT1_Format": "CompressedPixelFormat",
    "RGBA_S3TC_DXT3_Format": "CompressedPixelFormat",
    "RGBA_S3TC_DXT5_Format": "CompressedPixelFormat",
    "RGB_PVRTC_4BPPV1_Format": "CompressedPixelFormat",
    "RGB_PVRTC_2BPPV1_Format": "CompressedPixelFormat",
    "RGBA_PVRTC_4BPPV1_Format": "CompressedPixelFormat",
    "RGBA_PVRTC_2BPPV1_Format": "CompressedPixelFormat",
    "Camera": {
      "!type": "fn()",
      "prototype": {
        "matrixWorldInverse": "Matrix4",
        "projectionMatrix": "Matrix4",
        "getWorldDirection": "fn(optionalTarget?: Vector3) -> Vector3",
        "lookAt": "fn(vector: Vector3)",
        "clone": "fn(camera?: Camera) -> Camera"
      }
    },
    "CubeCamera": {
      "!type": "fn(near?: number, far?: number, cubeResolution?: number)",
      "prototype": {
        "renderTarget": "WebGLRenderTargetCube",
        "updateCubeMap": "fn(renderer: Renderer, scene: Scene)"
      }
    },
    "OrthographicCamera": {
      "!type": "fn(left: number, right: number, top: number, bottom: number, near?: number, far?: number)",
      "prototype": {
        "zoom": "number",
        "left": "number",
        "right": "number",
        "top": "number",
        "bottom": "number",
        "near": "number",
        "far": "number",
        "updateProjectionMatrix": "fn()",
        "clone": "fn() -> OrthographicCamera"
      }
    },
    "PerspectiveCamera": {
      "!type": "fn(fov?: number, aspect?: number, near?: number, far?: number)",
      "prototype": {
        "zoom": "number",
        "fov": "number",
        "aspect": "number",
        "near": "number",
        "far": "number",
        "setLens": "fn(focalLength: number, frameHeight?: number)",
        "setViewOffset": "fn(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number)",
        "updateProjectionMatrix": "fn()",
        "clone": "fn() -> PerspectiveCamera"
      }
    },
    "BufferAttribute": {
      "!type": "fn(array: ?, itemSize: number)",
      "prototype": {
        "array": "[number]",
        "itemSize": "number",
        "needsUpdate": "bool",
        "length": "number",
        "copyAt": "fn(index1: number, attribute: BufferAttribute, index2: number)",
        "set": "fn(value: number) -> BufferAttribute",
        "setX": "fn(index: number, x: number) -> BufferAttribute",
        "setY": "fn(index: number, y: number) -> BufferAttribute",
        "setZ": "fn(index: number, z: number) -> BufferAttribute",
        "setXY": "fn(index: number, x: number, y: number) -> BufferAttribute",
        "setXYZ": "fn(index: number, x: number, y: number, z: number) -> BufferAttribute",
        "setXYZW": "fn(index: number, x: number, y: number, z: number, w: number) -> BufferAttribute",
        "clone": "fn() -> BufferAttribute"
      }
    },
    "Int8Attribute": {
      "!type": "fn(data: ?, itemSize: number)",
      "prototype": {}
    },
    "Uint8Attribute": {
      "!type": "fn(data: ?, itemSize: number)",
      "prototype": {}
    },
    "Uint8ClampedAttribute": {
      "!type": "fn(data: ?, itemSize: number)",
      "prototype": {}
    },
    "Int16Attribute": {
      "!type": "fn(data: ?, itemSize: number)",
      "prototype": {}
    },
    "Uint16Attribute": {
      "!type": "fn(data: ?, itemSize: number)",
      "prototype": {}
    },
    "Int32Attribute": {
      "!type": "fn(data: ?, itemSize: number)",
      "prototype": {}
    },
    "Uint32Attribute": {
      "!type": "fn(data: ?, itemSize: number)",
      "prototype": {}
    },
    "Float32Attribute": {
      "!type": "fn(data: ?, itemSize: number)",
      "prototype": {}
    },
    "Float64Attribute": {
      "!type": "fn(data: ?, itemSize: number)",
      "prototype": {}
    },
    "BufferGeometry": {
      "!type": "fn()",
      "prototype": {
        "id": "number",
        "uuid": "string",
        "name": "string",
        "type": "string",
        "attributes": "[BufferAttribute]",
        "attributesKeys": "[string]",
        "drawcalls": "[]",
        "offsets": "[1]",
        "boundingBox": "Box3",
        "boundingSphere": "BoundingSphere",
        "addAttribute": "fn(name: string, attribute: BufferAttribute) -> ?",
        "getAttribute": "fn(name: string) -> ?",
        "addDrawCall": "fn(start: number, count: number, index: number)",
        "applyMatrix": "fn(matrix: Matrix4)",
        "center": "fn()",
        "fromGeometry": "fn(geometry: Geometry, settings?: ?) -> BufferGeometry",
        "computeBoundingBox": "fn()",
        "computeBoundingSphere": "fn()",
        "computeFaceNormals": "fn()",
        "computeVertexNormals": "fn()",
        "computeTangents": "fn()",
        "computeOffsets": "fn(indexBufferSize: number)",
        "merge": "fn(geometry: BufferGeometry, offset: number) -> BufferGeometry",
        "normalizeNormals": "fn()",
        "reorderBuffers": "fn(indexBuffer: number, indexMap: [number], vertexCount: number)",
        "toJSON": "fn() -> ?",
        "clone": "fn() -> BufferGeometry",
        "dispose": "fn()",
        "addEventListener": "fn(type: string, listener: fn(event: ?))",
        "hasEventListener": "fn(type: string, listener: fn(event: ?))",
        "removeEventListener": "fn(type: string, listener: fn(event: ?))",
        "dispatchEvent": "fn(event: [object Object])"
      }
    },
    "Clock": {
      "!type": "fn(autoStart?: bool)",
      "prototype": {
        "autoStart": "bool",
        "startTime": "number",
        "oldTime": "number",
        "elapsedTime": "number",
        "running": "bool",
        "start": "fn()",
        "stop": "fn()",
        "getElapsedTime": "fn() -> number",
        "getDelta": "fn() -> number"
      }
    },
    "EventDispatcher": {
      "!type": "fn()",
      "prototype": {
        "addEventListener": "fn(type: string, listener: fn(event: ?))",
        "hasEventListener": "fn(type: string, listener: fn(event: ?))",
        "removeEventListener": "fn(type: string, listener: fn(event: ?))",
        "dispatchEvent": "fn(event: [object Object])"
      }
    },
    "Face3": {
      "!type": "fn(a: number, b: number, c: number, normal?: Vector3, color?: Color, materialIndex?: number)",
      "prototype": {
        "a": "number",
        "b": "number",
        "c": "number",
        "normal": "Vector3",
        "vertexNormals": "[Vector3]",
        "color": "Color",
        "vertexColors": "[Color]",
        "vertexTangents": "[number]",
        "materialIndex": "number",
        "clone": "fn() -> Face3"
      }
    },
    "MorphTarget": {
      "name": "string",
      "vertices": "[Vector3]"
    },
    "MorphColor": {
      "name": "string",
      "colors": "[Color]"
    },
    "MorphNormals": {
      "name": "string",
      "normals": "[Vector3]"
    },
    "BoundingSphere": {
      "radius": "number"
    },
    "Geometry": {
      "!type": "fn()",
      "prototype": {
        "id": "number",
        "uuid": "string",
        "name": "string",
        "type": "string",
        "vertices": "[Vector3]",
        "colors": "[Color]",
        "faces": "[Face3]",
        "faceVertexUvs": "[[[Vector2]]]",
        "morphTargets": "[MorphTarget]",
        "morphColors": "[MorphColor]",
        "morphNormals": "[MorphNormals]",
        "skinWeights": "[number]",
        "skinIndices": "[number]",
        "lineDistances": "[number]",
        "boundingBox": "Box3",
        "boundingSphere": "BoundingSphere",
        "hasTangents": "bool",
        "dynamic": "bool",
        "verticesNeedUpdate": "bool",
        "elementsNeedUpdate": "bool",
        "uvsNeedUpdate": "bool",
        "normalsNeedUpdate": "bool",
        "tangentsNeedUpdate": "bool",
        "colorsNeedUpdate": "bool",
        "lineDistancesNeedUpdate": "bool",
        "groupsNeedUpdate": "bool",
        "applyMatrix": "fn(matrix: Matrix4)",
        "fromBufferGeometry": "fn(geometry: BufferGeometry) -> Geometry",
        "center": "fn() -> Vector3",
        "computeFaceNormals": "fn()",
        "computeVertexNormals": "fn(areaWeighted?: bool)",
        "computeMorphNormals": "fn()",
        "computeTangents": "fn()",
        "computeLineDistances": "fn()",
        "computeBoundingBox": "fn()",
        "computeBoundingSphere": "fn()",
        "merge": "fn(geometry: Geometry, matrix: Matrix, materialIndexOffset: number)",
        "mergeMesh": "fn(mesh: Mesh)",
        "mergeVertices": "fn() -> number",
        "toJSON": "fn() -> ?",
        "clone": "fn() -> Geometry",
        "dispose": "fn()",
        "bones": "[Bone]",
        "animation": "AnimationData",
        "animations": "[AnimationData]",
        "addEventListener": "fn(type: string, listener: fn(event: ?))",
        "hasEventListener": "fn(type: string, listener: fn(event: ?))",
        "removeEventListener": "fn(type: string, listener: fn(event: ?))",
        "dispatchEvent": "fn(event: [object Object])"
      }
    },
    "Object3D": {
      "!type": "fn()",
      "DefaultUp": "Vector3",
      "prototype": {
        "id": "number",
        "uuid": "string",
        "name": "string",
        "type": "string",
        "parent": "Object3D",
        "children": "[Object3D]",
        "up": "Vector3",
        "position": "Vector3",
        "rotation": "Euler",
        "quaternion": "Quaternion",
        "scale": "Vector3",
        "rotationAutoUpdate": "bool",
        "matrix": "Matrix4",
        "matrixWorld": "Matrix4",
        "matrixAutoUpdate": "bool",
        "matrixWorldNeedsUpdate": "bool",
        "visible": "bool",
        "castShadow": "bool",
        "receiveShadow": "bool",
        "frustumCulled": "bool",
        "userData": "?",
        "eulerOrder": "string",
        "applyMatrix": "fn(matrix: Matrix4)",
        "setRotationFromAxisAngle": "fn(axis: Vector3, angle: number)",
        "setRotationFromEuler": "fn(euler: Euler)",
        "setRotationFromMatrix": "fn(m: Matrix4)",
        "setRotationFromQuaternion": "fn(q: Quaternion)",
        "rotateOnAxis": "fn(axis: Vector3, angle: number) -> Object3D",
        "rotateX": "fn(angle: number) -> Object3D",
        "rotateY": "fn(angle: number) -> Object3D",
        "rotateZ": "fn(angle: number) -> Object3D",
        "translateOnAxis": "fn(axis: Vector3, distance: number) -> Object3D",
        "translate": "fn(distance: number, axis: Vector3) -> Object3D",
        "translateX": "fn(distance: number) -> Object3D",
        "translateY": "fn(distance: number) -> Object3D",
        "translateZ": "fn(distance: number) -> Object3D",
        "localToWorld": "fn(vector: Vector3) -> Vector3",
        "worldToLocal": "fn(vector: Vector3) -> Vector3",
        "lookAt": "fn(vector: Vector3)",
        "add": "fn(object: Object3D)",
        "remove": "fn(object: Object3D)",
        "getChildByName": "fn(name: string, recursive?: bool) -> Object3D",
        "getObjectById": "fn(id: string, recursive: bool) -> Object3D",
        "getObjectByName": "fn(name: string, recursive?: bool) -> Object3D",
        "getObjectByProperty": "fn(name: string, value: string, recursive?: bool) -> Object3D",
        "getWorldPosition": "fn(optionalTarget: Vector3) -> Vector3",
        "getWorldQuaternion": "fn(optionalTarget: Quaternion) -> Quaternion",
        "getWorldRotation": "fn(optionalTarget: Euler) -> Euler",
        "getWorldScale": "fn(optionalTarget: Vector3) -> Vector3",
        "getWorldDirection": "fn(optionalTarget: Vector3) -> Vector3",
        "traverse": "fn(callback: fn(object: Object3D))",
        "traverseVisible": "fn(callback: fn(object: Object3D))",
        "traverseAncestors": "fn(callback: fn(object: Object3D))",
        "updateMatrix": "fn()",
        "updateMatrixWorld": "fn(force: bool)",
        "toJSON": "fn() -> ?",
        "clone": "fn(object?: Object3D, recursive?: bool) -> Object3D",
        "addEventListener": "fn(type: string, listener: fn(event: ?))",
        "hasEventListener": "fn(type: string, listener: fn(event: ?))",
        "removeEventListener": "fn(type: string, listener: fn(event: ?))",
        "dispatchEvent": "fn(event: [object Object])"
      }
    },
    "Intersection": {
      "distance": "number",
      "point": "Vector3",
      "face": "Face3",
      "object": "Object3D"
    },
    "RaycasterParameters": {
      "Sprite": "?",
      "Mesh": "?",
      "PointCloud": "?",
      "LOD": "?",
      "Line": "?"
    },
    "Raycaster": {
      "!type": "fn(origin?: Vector3, direction?: Vector3, near?: number, far?: number)",
      "prototype": {
        "ray": "Ray",
        "near": "number",
        "far": "number",
        "params": "RaycasterParameters",
        "precision": "number",
        "linePrecision": "number",
        "set": "fn(origin: Vector3, direction: Vector3)",
        "setFromCamera": "fn(coords: [object Object], camera: Camera)",
        "intersectObject": "fn(object: Object3D, recursive?: bool) -> [Intersection]",
        "intersectObjects": "fn(objects: [Object3D], recursive?: bool) -> [Intersection]"
      }
    },
    "Light": {
      "!type": "fn(hex?: number)",
      "prototype": {
        "color": "Color",
        "clone": "fn(light?: Light) -> Light"
      }
    },
    "AmbientLight": {
      "!type": "fn(hex?: number)",
      "prototype": {
        "clone": "fn() -> AmbientLight"
      }
    },
    "AreaLight": {
      "!type": "fn(hex: number, intensity?: number)",
      "prototype": {
        "normal": "Vector3",
        "right": "Vector3",
        "intensity": "number",
        "width": "number",
        "height": "number",
        "constantAttenuation": "number",
        "linearAttenuation": "number",
        "quadraticAttenuation": "number"
      }
    },
    "DirectionalLight": {
      "!type": "fn(hex?: number, intensity?: number)",
      "prototype": {
        "target": "Object3D",
        "intensity": "number",
        "castShadow": "bool",
        "onlyShadow": "bool",
        "shadowCameraNear": "number",
        "shadowCameraFar": "number",
        "shadowCameraLeft": "number",
        "shadowCameraRight": "number",
        "shadowCameraTop": "number",
        "shadowCameraBottom": "number",
        "shadowCameraVisible": "bool",
        "shadowBias": "number",
        "shadowDarkness": "number",
        "shadowMapWidth": "number",
        "shadowMapHeight": "number",
        "shadowCascade": "bool",
        "shadowCascadeOffset": "Vector3",
        "shadowCascadeCount": "number",
        "shadowCascadeBias": "[number]",
        "shadowCascadeWidth": "[number]",
        "shadowCascadeHeight": "[number]",
        "shadowCascadeNearZ": "[number]",
        "shadowCascadeFarZ": "[number]",
        "shadowCascadeArray": "[DirectionalLight]",
        "shadowMap": "RenderTarget",
        "shadowMapSize": "number",
        "shadowCamera": "Camera",
        "shadowMatrix": "Matrix4",
        "clone": "fn() -> DirectionalLight"
      }
    },
    "HemisphereLight": {
      "!type": "fn(skyColorHex?: number, groundColorHex?: number, intensity?: number)",
      "prototype": {
        "groundColor": "Color",
        "intensity": "number",
        "clone": "fn() -> HemisphereLight"
      }
    },
    "PointLight": {
      "!type": "fn(hex?: number, intensity?: number, distance?: number)",
      "prototype": {
        "intensity": "number",
        "distance": "number",
        "clone": "fn() -> PointLight"
      }
    },
    "SpotLight": {
      "!type": "fn(hex?: number, intensity?: number, distance?: number, angle?: number, exponent?: number)",
      "prototype": {
        "target": "Object3D",
        "intensity": "number",
        "distance": "number",
        "angle": "number",
        "exponent": "number",
        "castShadow": "bool",
        "onlyShadow": "bool",
        "shadowCameraNear": "number",
        "shadowCameraFar": "number",
        "shadowCameraFov": "number",
        "shadowCameraVisible": "bool",
        "shadowBias": "number",
        "shadowDarkness": "number",
        "shadowMapWidth": "number",
        "shadowMapHeight": "number",
        "shadowMap": "RenderTarget",
        "shadowMapSize": "Vector2",
        "shadowCamera": "Camera",
        "shadowMatrix": "Matrix4",
        "clone": "fn() -> SpotLight"
      }
    },
    "Progress": {
      "total": "number",
      "loaded": "number"
    },
    "Loader": {
      "!type": "fn(showStatus?: bool)",
      "Handlers": "LoaderHandler",
      "prototype": {
        "showStatus": "bool",
        "statusDomElement": "HTMLElement",
        "imageLoader": "ImageLoader",
        "onLoadStart": "fn()",
        "onLoadProgress": "fn()",
        "onLoadComplete": "fn()",
        "crossOrigin": "string",
        "addStatusElement": "fn() -> HTMLElement",
        "updateProgress": "fn(progress: Progress)",
        "extractUrlBase": "fn(url: string) -> string",
        "initMaterials": "fn(materials: [Material], texturePath: string) -> [Material]",
        "needsTangents": "fn(materials: [Material]) -> bool",
        "createMaterial": "fn(m: Material, texturePath: string) -> bool"
      }
    },
    "LoaderHandler": {
      "handlers": "[?]",
      "add": "fn(regex: string, loader: Loader)",
      "get": "fn(file: string) -> Loader"
    },
    "BinaryTextureLoader": {
      "!type": "fn()",
      "prototype": {
        "load": "fn(url: string, onLoad: fn(dataTexture: DataTexture), onProgress?: fn(event: ?), onError?: fn(event: ?))"
      }
    },
    "BufferGeometryLoader": {
      "!type": "fn(manager?: LoadingManager)",
      "prototype": {
        "manager": "LoadingManager",
        "load": "fn(url: string, onLoad: fn(bufferGeometry: BufferGeometry), onProgress?: fn(event: ?), onError?: fn(event: ?))",
        "setCrossOrigin": "fn(crossOrigin: string)",
        "parse": "fn(json: ?) -> BufferGeometry"
      }
    },
    "Cache": {
      "!type": "fn()",
      "prototype": {
        "files": "[?]",
        "add": "fn(key: string, file: ?)",
        "get": "fn(key: string) -> ?",
        "remove": "fn(key: string)",
        "clear": "fn()"
      }
    },
    "CompressedTextureLoader": {
      "!type": "fn()",
      "prototype": {
        "load": "fn(url: string, onLoad: fn(bufferGeometry: BufferGeometry), onError?: fn(event: ?))"
      }
    },
    "DataTextureLoader": {
      "prototype": {}
    },
    "ImageLoader": {
      "!type": "fn(manager?: LoadingManager)",
      "prototype": {
        "cache": "Cache",
        "manager": "LoadingManager",
        "crossOrigin": "string",
        "load": "fn(url: string, onLoad?: fn(image: HTMLImageElement), onProgress?: fn(event: ?), onError?: fn(event: ?)) -> HTMLImageElement",
        "setCrossOrigin": "fn(crossOrigin: string)"
      }
    },
    "JSONLoader": {
      "!type": "fn(showStatus?: bool)",
      "prototype": {
        "withCredentials": "bool",
        "load": "fn(url: string, callback: fn(geometry: Geometry, materials: [Material]), texturePath?: string)",
        "loadAjaxJSON": "fn(context: JSONLoader, url: string, callback: fn(geometry: Geometry, materials: [Material]), texturePath?: string, callbackProgress?: fn(progress: Progress))",
        "parse": "fn(json: ?, texturePath?: string) -> ret"
      }
    },
    "LoadingManager": {
      "!type": "fn(onLoad?: fn(), onProgress?: fn(url: string, loaded: number, total: number), onError?: fn())",
      "prototype": {
        "onLoad": "fn()",
        "onProgress": "fn(item: ?, loaded: number, total: number)",
        "onError": "fn()",
        "itemStart": "fn(url: string)",
        "itemEnd": "fn(url: string)"
      }
    },
    "MaterialLoader": {
      "!type": "fn(manager?: LoadingManager)",
      "prototype": {
        "manager": "LoadingManager",
        "load": "fn(url: string, onLoad: fn(material: Material))",
        "setCrossOrigin": "fn(crossOrigin: string)",
        "parse": "fn(json: ?) -> Material"
      }
    },
    "ObjectLoader": {
      "!type": "fn(manager?: LoadingManager)",
      "prototype": {
        "manager": "LoadingManager",
        "crossOrigin": "string",
        "load": "fn(url: string, onLoad: fn(object: Object3D))",
        "setCrossOrigin": "fn(crossOrigin: string)",
        "parse": "fn(json: ?) -> T",
        "parseGeometries": "fn(json: ?) -> [?]",
        "parseMaterials": "fn(json: ?) -> [Material]",
        "parseObject": "fn(data: ?, geometries: [?], materials: [Material]) -> T"
      }
    },
    "TextureLoader": {
      "!type": "fn(manager?: LoadingManager)",
      "prototype": {
        "manager": "LoadingManager",
        "crossOrigin": "string",
        "load": "fn(url: string, onLoad: fn(texture: Texture))",
        "setCrossOrigin": "fn(crossOrigin: string)"
      }
    },
    "XHRLoader": {
      "!type": "fn(manager?: LoadingManager)",
      "prototype": {
        "cache": "Cache",
        "manager": "LoadingManager",
        "responseType": "string",
        "crossOrigin": "string",
        "load": "fn(url: string, onLoad?: fn(responseText: string), onProgress?: fn(event: ?), onError?: fn(event: ?))",
        "setResponseType": "fn(responseType: string)",
        "setCrossOrigin": "fn(crossOrigin: string)"
      }
    },
    "MaterialParameters": {
      "name": "string",
      "side": "Side",
      "opacity": "number",
      "transparent": "bool",
      "blending": "Blending",
      "blendSrc": "BlendingDstFactor",
      "blendDst": "BlendingSrcFactor",
      "blendEquation": "BlendingEquation",
      "depthTest": "bool",
      "depthWrite": "bool",
      "polygonOffset": "bool",
      "polygonOffsetFactor": "number",
      "polygonOffsetUnits": "number",
      "alphaTest": "number",
      "overdraw": "number",
      "visible": "bool",
      "needsUpdate": "bool"
    },
    "Material": {
      "!type": "fn()",
      "prototype": {
        "id": "number",
        "uuid": "string",
        "name": "string",
        "type": "string",
        "side": "Side",
        "opacity": "number",
        "transparent": "bool",
        "blending": "Blending",
        "blendSrc": "BlendingDstFactor",
        "blendDst": "BlendingSrcFactor",
        "blendEquation": "BlendingEquation",
        "depthTest": "bool",
        "depthWrite": "bool",
        "polygonOffset": "bool",
        "polygonOffsetFactor": "number",
        "polygonOffsetUnits": "number",
        "alphaTest": "number",
        "overdraw": "number",
        "visible": "bool",
        "needsUpdate": "bool",
        "setValues": "fn(values: Object)",
        "toJSON": "fn() -> ?",
        "clone": "fn(material?: Material) -> Material",
        "dispose": "fn()",
        "addEventListener": "fn(type: string, listener: fn(event: ?))",
        "hasEventListener": "fn(type: string, listener: fn(event: ?))",
        "removeEventListener": "fn(type: string, listener: fn(event: ?))",
        "dispatchEvent": "fn(event: [object Object])"
      }
    },
    "LineBasicMaterialParameters": {
      "color": "number",
      "linewidth": "number",
      "linecap": "string",
      "linejoin": "string",
      "vertexColors": "Colors",
      "fog": "bool"
    },
    "LineBasicMaterial": {
      "!type": "fn(parameters?: LineBasicMaterialParameters)",
      "prototype": {
        "color": "Color",
        "linewidth": "number",
        "linecap": "string",
        "linejoin": "string",
        "vertexColors": "Colors",
        "fog": "bool",
        "clone": "fn() -> LineBasicMaterial"
      }
    },
    "LineDashedMaterialParameters": {
      "color": "number",
      "linewidth": "number",
      "scale": "number",
      "dashSize": "number",
      "gapSize": "number",
      "vertexColors": "Colors",
      "fog": "bool"
    },
    "LineDashedMaterial": {
      "!type": "fn(parameters?: LineDashedMaterialParameters)",
      "prototype": {
        "color": "Color",
        "linewidth": "number",
        "scale": "number",
        "dashSize": "number",
        "gapSize": "number",
        "vertexColors": "Colors",
        "fog": "bool",
        "clone": "fn() -> LineDashedMaterial"
      }
    },
    "MeshBasicMaterialParameters": {
      "color": "number",
      "map": "Texture",
      "lightMap": "Texture",
      "specularMap": "Texture",
      "alphaMap": "Texture",
      "envMap": "Texture",
      "combine": "Combine",
      "reflectivity": "number",
      "refractionRatio": "number",
      "fog": "bool",
      "shading": "Shading",
      "wireframe": "bool",
      "wireframeLinewidth": "number",
      "wireframeLinecap": "string",
      "wireframeLinejoin": "string",
      "vertexColors": "Colors",
      "skinning": "bool",
      "morphTargets": "bool"
    },
    "MeshBasicMaterial": {
      "!type": "fn(parameters?: MeshBasicMaterialParameters)",
      "prototype": {
        "color": "Color",
        "map": "Texture",
        "lightMap": "Texture",
        "specularMap": "Texture",
        "alphaMap": "Texture",
        "envMap": "Texture",
        "combine": "Combine",
        "reflectivity": "number",
        "refractionRatio": "number",
        "fog": "bool",
        "shading": "Shading",
        "wireframe": "bool",
        "wireframeLinewidth": "number",
        "wireframeLinecap": "string",
        "wireframeLinejoin": "string",
        "vertexColors": "Colors",
        "skinning": "bool",
        "morphTargets": "bool",
        "clone": "fn() -> MeshBasicMaterial"
      }
    },
    "MeshDepthMaterialParameters": {
      "wireframe": "bool",
      "wireframeLinewidth": "number"
    },
    "MeshDepthMaterial": {
      "!type": "fn(parameters?: MeshDepthMaterialParameters)",
      "prototype": {
        "wireframe": "bool",
        "wireframeLinewidth": "number",
        "clone": "fn() -> MeshDepthMaterial"
      }
    },
    "MeshFaceMaterial": {
      "!type": "fn(materials?: [Material])",
      "prototype": {
        "materials": "[Material]",
        "toJSON": "fn() -> ?",
        "clone": "fn() -> MeshFaceMaterial"
      }
    },
    "MeshLambertMaterialParameters": {
      "color": "number",
      "ambient": "number",
      "emissive": "number",
      "wrapAround": "bool",
      "wrapRGB": "Vector3",
      "map": "Texture",
      "lightMap": "Texture",
      "specularMap": "Texture",
      "alphaMap": "Texture",
      "envMap": "Texture",
      "combine": "Combine",
      "reflectivity": "number",
      "refractionRatio": "number",
      "fog": "bool",
      "shading": "Shading",
      "wireframe": "bool",
      "wireframeLinewidth": "number",
      "wireframeLinecap": "string",
      "wireframeLinejoin": "string",
      "vertexColors": "Colors",
      "skinning": "bool",
      "morphTargets": "bool",
      "morphNormals": "bool"
    },
    "MeshLambertMaterial": {
      "!type": "fn(parameters?: MeshLambertMaterialParameters)",
      "prototype": {
        "color": "Color",
        "ambient": "Color",
        "emissive": "Color",
        "wrapAround": "bool",
        "wrapRGB": "Vector3",
        "map": "Texture",
        "lightMap": "Texture",
        "specularMap": "Texture",
        "alphaMap": "Texture",
        "envMap": "Texture",
        "combine": "Combine",
        "reflectivity": "number",
        "refractionRatio": "number",
        "fog": "bool",
        "shading": "Shading",
        "wireframe": "bool",
        "wireframeLinewidth": "number",
        "wireframeLinecap": "string",
        "wireframeLinejoin": "string",
        "vertexColors": "Colors",
        "skinning": "bool",
        "morphTargets": "bool",
        "morphNormals": "bool",
        "clone": "fn() -> MeshLambertMaterial"
      }
    },
    "MeshNormalMaterialParameters": {
      "shading": "Shading",
      "wireframe": "bool",
      "wireframeLinewidth": "number",
      "morphTargets": "bool"
    },
    "MeshNormalMaterial": {
      "!type": "fn(parameters?: MeshNormalMaterialParameters)",
      "prototype": {
        "shading": "Shading",
        "wireframe": "bool",
        "wireframeLinewidth": "number",
        "morphTargets": "bool",
        "clone": "fn() -> MeshNormalMaterial"
      }
    },
    "MeshPhongMaterialParameters": {
      "color": "number",
      "ambient": "number",
      "emissive": "number",
      "specular": "number",
      "shininess": "number",
      "metal": "bool",
      "wrapAround": "bool",
      "wrapRGB": "Vector3",
      "map": "Texture",
      "lightMap": "Texture",
      "bumpMap": "Texture",
      "bumpScale": "number",
      "normalMap": "Texture",
      "normalScale": "Vector2",
      "specularMap": "Texture",
      "alphaMap": "Texture",
      "envMap": "Texture",
      "combine": "Combine",
      "reflectivity": "number",
      "refractionRatio": "number",
      "fog": "bool",
      "shading": "Shading",
      "wireframe": "bool",
      "wireframeLinewidth": "number",
      "wireframeLinecap": "string",
      "wireframeLinejoin": "string",
      "vertexColors": "Colors",
      "skinning": "bool",
      "morphTargets": "bool",
      "morphNormals": "bool"
    },
    "MeshPhongMaterial": {
      "!type": "fn(parameters?: MeshPhongMaterialParameters)",
      "prototype": {
        "color": "Color",
        "ambient": "Color",
        "emissive": "Color",
        "specular": "Color",
        "shininess": "number",
        "metal": "bool",
        "wrapAround": "bool",
        "wrapRGB": "Vector3",
        "map": "Texture",
        "lightMap": "Texture",
        "bumpMap": "Texture",
        "bumpScale": "number",
        "normalMap": "Texture",
        "normalScale": "Vector2",
        "specularMap": "Texture",
        "alphaMap": "Texture",
        "envMap": "Texture",
        "combine": "Combine",
        "reflectivity": "number",
        "refractionRatio": "number",
        "fog": "bool",
        "shading": "Shading",
        "wireframe": "bool",
        "wireframeLinewidth": "number",
        "wireframeLinecap": "string",
        "wireframeLinejoin": "string",
        "vertexColors": "Colors",
        "skinning": "bool",
        "morphTargets": "bool",
        "morphNormals": "bool",
        "clone": "fn() -> MeshPhongMaterial"
      }
    },
    "PointCloudMaterialParameters": {
      "color": "number",
      "map": "Texture",
      "size": "number",
      "sizeAttenuation": "bool",
      "vertexColors": "Colors",
      "fog": "bool"
    },
    "PointCloudMaterial": {
      "!type": "fn(parameters?: PointCloudMaterialParameters)",
      "prototype": {
        "color": "Color",
        "map": "Texture",
        "size": "number",
        "sizeAttenuation": "bool",
        "vertexColors": "bool",
        "fog": "bool",
        "clone": "fn() -> PointCloudMaterial"
      }
    },
    "ParticleBasicMaterial": {
      "prototype": {}
    },
    "ParticleSystemMaterial": {
      "prototype": {}
    },
    "RawShaderMaterial": {
      "!type": "fn(parameters?: ShaderMaterialParameters)",
      "prototype": {}
    },
    "ShaderMaterialParameters": {
      "defines": "?",
      "uniforms": "?",
      "attributes": "?",
      "vertexShader": "string",
      "fragmentShader": "string",
      "shading": "Shading",
      "linewidth": "number",
      "wireframe": "bool",
      "wireframeLinewidth": "number",
      "fog": "bool",
      "lights": "bool",
      "vertexColors": "Colors",
      "skinning": "bool",
      "morphTargets": "bool",
      "morphNormals": "bool"
    },
    "ShaderMaterial": {
      "!type": "fn(parameters?: ShaderMaterialParameters)",
      "prototype": {
        "defines": "?",
        "uniforms": "?",
        "attributes": "?",
        "vertexShader": "string",
        "fragmentShader": "string",
        "shading": "Shading",
        "linewidth": "number",
        "wireframe": "bool",
        "wireframeLinewidth": "number",
        "fog": "bool",
        "lights": "bool",
        "vertexColors": "Colors",
        "skinning": "bool",
        "morphTargets": "bool",
        "morphNormals": "bool",
        "clone": "fn() -> ShaderMaterial"
      }
    },
    "SpriteMaterialParameters": {
      "color": "number",
      "map": "Texture",
      "rotation": "number",
      "fog": "bool"
    },
    "SpriteMaterial": {
      "!type": "fn(parameters?: SpriteMaterialParameters)",
      "prototype": {
        "color": "Color",
        "map": "Texture",
        "rotation": "number",
        "fog": "bool",
        "clone": "fn() -> SpriteMaterial"
      }
    },
    "Box2": {
      "!type": "fn(min?: Vector2, max?: Vector2)",
      "prototype": {
        "max": "Vector2",
        "min": "Vector2",
        "set": "fn(min: Vector2, max: Vector2) -> Box2",
        "setFromPoints": "fn(points: [Vector2]) -> Box2",
        "setFromCenterAndSize": "fn(center: Vector2, size: Vector2) -> Box2",
        "copy": "fn(box: Box2) -> Box2",
        "makeEmpty": "fn() -> Box2",
        "empty": "fn() -> bool",
        "center": "fn(optionalTarget?: Vector2) -> Vector2",
        "size": "fn(optionalTarget?: Vector2) -> Vector2",
        "expandByPoint": "fn(point: Vector2) -> Box2",
        "expandByVector": "fn(vector: Vector2) -> Box2",
        "expandByScalar": "fn(scalar: number) -> Box2",
        "containsPoint": "fn(point: Vector2) -> bool",
        "containsBox": "fn(box: Box2) -> bool",
        "getParameter": "fn(point: Vector2) -> Vector2",
        "isIntersectionBox": "fn(box: Box2) -> bool",
        "clampPoint": "fn(point: Vector2, optionalTarget?: Vector2) -> Vector2",
        "distanceToPoint": "fn(point: Vector2) -> number",
        "intersect": "fn(box: Box2) -> Box2",
        "union": "fn(box: Box2) -> Box2",
        "translate": "fn(offset: Vector2) -> Box2",
        "equals": "fn(box: Box2) -> bool",
        "clone": "fn() -> Box2"
      }
    },
    "Box3": {
      "!type": "fn(min?: Vector3, max?: Vector3)",
      "prototype": {
        "max": "Vector3",
        "min": "Vector3",
        "set": "fn(min: Vector3, max: Vector3) -> Box3",
        "setFromPoints": "fn(points: [Vector3]) -> Box3",
        "setFromCenterAndSize": "fn(center: Vector3, size: Vector3) -> Box3",
        "setFromObject": "fn(object: Object3D) -> Box3",
        "copy": "fn(box: Box3) -> Box3",
        "makeEmpty": "fn() -> Box3",
        "empty": "fn() -> bool",
        "center": "fn(optionalTarget?: Vector3) -> Vector3",
        "size": "fn(optionalTarget?: Vector3) -> Vector3",
        "expandByPoint": "fn(point: Vector3) -> Box3",
        "expandByVector": "fn(vector: Vector3) -> Box3",
        "expandByScalar": "fn(scalar: number) -> Box3",
        "containsPoint": "fn(point: Vector3) -> bool",
        "containsBox": "fn(box: Box3) -> bool",
        "getParameter": "fn(point: Vector3) -> Vector3",
        "isIntersectionBox": "fn(box: Box3) -> bool",
        "clampPoint": "fn(point: Vector3, optionalTarget?: Vector3) -> Vector3",
        "distanceToPoint": "fn(point: Vector3) -> number",
        "getBoundingSphere": "fn(optionalTarget?: Sphere) -> Sphere",
        "intersect": "fn(box: Box3) -> Box3",
        "union": "fn(box: Box3) -> Box3",
        "applyMatrix4": "fn(matrix: Matrix4) -> Box3",
        "translate": "fn(offset: Vector3) -> Box3",
        "equals": "fn(box: Box3) -> bool",
        "clone": "fn() -> Box3"
      }
    },
    "HSL": {
      "h": "number",
      "s": "number",
      "l": "number"
    },
    "Color": {
      "!type": "fn(color?: Color)",
      "prototype": {
        "r": "number",
        "g": "number",
        "b": "number",
        "set": "fn(color: Color) -> Color",
        "setHex": "fn(hex: number) -> Color",
        "setRGB": "fn(r: number, g: number, b: number) -> Color",
        "setHSL": "fn(h: number, s: number, l: number) -> Color",
        "setStyle": "fn(style: string) -> Color",
        "copy": "fn(color: Color) -> Color",
        "copyGammaToLinear": "fn(color: Color) -> Color",
        "copyLinearToGamma": "fn(color: Color) -> Color",
        "convertGammaToLinear": "fn() -> Color",
        "convertLinearToGamma": "fn() -> Color",
        "getHex": "fn() -> number",
        "getHexString": "fn() -> string",
        "getHSL": "fn() -> HSL",
        "getStyle": "fn() -> string",
        "offsetHSL": "fn(h: number, s: number, l: number) -> Color",
        "add": "fn(color: Color) -> Color",
        "addColors": "fn(color1: Color, color2: Color) -> Color",
        "addScalar": "fn(s: number) -> Color",
        "multiply": "fn(color: Color) -> Color",
        "multiplyScalar": "fn(s: number) -> Color",
        "lerp": "fn(color: Color, alpha: number) -> Color",
        "equals": "fn(color: Color) -> bool",
        "fromArray": "fn(rgb: [number]) -> Color",
        "toArray": "fn() -> [number]",
        "clone": "fn() -> Color"
      }
    },
    "ColorKeywords": {
      "aliceblue": "number",
      "antiquewhite": "number",
      "aqua": "number",
      "aquamarine": "number",
      "azure": "number",
      "beige": "number",
      "bisque": "number",
      "black": "number",
      "blanchedalmond": "number",
      "blue": "number",
      "blueviolet": "number",
      "brown": "number",
      "burlywood": "number",
      "cadetblue": "number",
      "chartreuse": "number",
      "chocolate": "number",
      "coral": "number",
      "cornflowerblue": "number",
      "cornsilk": "number",
      "crimson": "number",
      "cyan": "number",
      "darkblue": "number",
      "darkcyan": "number",
      "darkgoldenrod": "number",
      "darkgray": "number",
      "darkgreen": "number",
      "darkgrey": "number",
      "darkkhaki": "number",
      "darkmagenta": "number",
      "darkolivegreen": "number",
      "darkorange": "number",
      "darkorchid": "number",
      "darkred": "number",
      "darksalmon": "number",
      "darkseagreen": "number",
      "darkslateblue": "number",
      "darkslategray": "number",
      "darkslategrey": "number",
      "darkturquoise": "number",
      "darkviolet": "number",
      "deeppink": "number",
      "deepskyblue": "number",
      "dimgray": "number",
      "dimgrey": "number",
      "dodgerblue": "number",
      "firebrick": "number",
      "floralwhite": "number",
      "forestgreen": "number",
      "fuchsia": "number",
      "gainsboro": "number",
      "ghostwhite": "number",
      "gold": "number",
      "goldenrod": "number",
      "gray": "number",
      "green": "number",
      "greenyellow": "number",
      "grey": "number",
      "honeydew": "number",
      "hotpink": "number",
      "indianred": "number",
      "indigo": "number",
      "ivory": "number",
      "khaki": "number",
      "lavender": "number",
      "lavenderblush": "number",
      "lawngreen": "number",
      "lemonchiffon": "number",
      "lightblue": "number",
      "lightcoral": "number",
      "lightcyan": "number",
      "lightgoldenrodyellow": "number",
      "lightgray": "number",
      "lightgreen": "number",
      "lightgrey": "number",
      "lightpink": "number",
      "lightsalmon": "number",
      "lightseagreen": "number",
      "lightskyblue": "number",
      "lightslategray": "number",
      "lightslategrey": "number",
      "lightsteelblue": "number",
      "lightyellow": "number",
      "lime": "number",
      "limegreen": "number",
      "linen": "number",
      "magenta": "number",
      "maroon": "number",
      "mediumaquamarine": "number",
      "mediumblue": "number",
      "mediumorchid": "number",
      "mediumpurple": "number",
      "mediumseagreen": "number",
      "mediumslateblue": "number",
      "mediumspringgreen": "number",
      "mediumturquoise": "number",
      "mediumvioletred": "number",
      "midnightblue": "number",
      "mintcream": "number",
      "mistyrose": "number",
      "moccasin": "number",
      "navajowhite": "number",
      "navy": "number",
      "oldlace": "number",
      "olive": "number",
      "olivedrab": "number",
      "orange": "number",
      "orangered": "number",
      "orchid": "number",
      "palegoldenrod": "number",
      "palegreen": "number",
      "paleturquoise": "number",
      "palevioletred": "number",
      "papayawhip": "number",
      "peachpuff": "number",
      "peru": "number",
      "pink": "number",
      "plum": "number",
      "powderblue": "number",
      "purple": "number",
      "red": "number",
      "rosybrown": "number",
      "royalblue": "number",
      "saddlebrown": "number",
      "salmon": "number",
      "sandybrown": "number",
      "seagreen": "number",
      "seashell": "number",
      "sienna": "number",
      "silver": "number",
      "skyblue": "number",
      "slateblue": "number",
      "slategray": "number",
      "slategrey": "number",
      "snow": "number",
      "springgreen": "number",
      "steelblue": "number",
      "tan": "number",
      "teal": "number",
      "thistle": "number",
      "tomato": "number",
      "turquoise": "number",
      "violet": "number",
      "wheat": "number",
      "white": "number",
      "whitesmoke": "number",
      "yellow": "number",
      "yellowgreen": "number",
      "prototype": {}
    },
    "Euler": {
      "!type": "fn(x?: number, y?: number, z?: number, order?: string)",
      "prototype": {
        "x": "number",
        "y": "number",
        "z": "number",
        "order": "string",
        "set": "fn(x: number, y: number, z: number, order?: string) -> Euler",
        "copy": "fn(euler: Euler) -> Euler",
        "setFromRotationMatrix": "fn(m: Matrix4, order?: string, update?: bool) -> Euler",
        "setFromQuaternion": "fn(q: Quaternion, order?: string, update?: bool) -> Euler",
        "setFromVector3": "fn(v: Vector3, order?: string) -> Euler",
        "reorder": "fn(newOrder: string) -> Euler",
        "equals": "fn(euler: Euler) -> bool",
        "fromArray": "fn(xyzo: [?]) -> Euler",
        "toArray": "fn() -> [?]",
        "toVector3": "fn(optionalResult?: Vector3) -> Vector3",
        "onChange": "fn()",
        "clone": "fn() -> Euler"
      }
    },
    "Frustum": {
      "!type": "fn(p0?: Plane, p1?: Plane, p2?: Plane, p3?: Plane, p4?: Plane, p5?: Plane)",
      "prototype": {
        "planes": "[Plane]",
        "set": "fn(p0?: number, p1?: number, p2?: number, p3?: number, p4?: number, p5?: number) -> Frustum",
        "copy": "fn(frustum: Frustum) -> Frustum",
        "setFromMatrix": "fn(m: Matrix4) -> Frustum",
        "intersectsObject": "fn(object: Object3D) -> bool",
        "intersectsSphere": "fn(sphere: Sphere) -> bool",
        "intersectsBox": "fn(box: Box3) -> bool",
        "containsPoint": "fn(point: Vector3) -> bool",
        "clone": "fn() -> Frustum"
      }
    },
    "Line3": {
      "!type": "fn(start?: Vector3, end?: Vector3)",
      "prototype": {
        "start": "Vector3",
        "end": "Vector3",
        "set": "fn(start?: Vector3, end?: Vector3) -> Line3",
        "copy": "fn(line: Line3) -> Line3",
        "center": "fn(optionalTarget?: Vector3) -> Vector3",
        "delta": "fn(optionalTarget?: Vector3) -> Vector3",
        "distanceSq": "fn() -> number",
        "distance": "fn() -> number",
        "at": "fn(t: number, optionalTarget?: Vector3) -> Vector3",
        "closestPointToPointParameter": "fn(point: Vector3, clampToLine?: bool) -> number",
        "closestPointToPoint": "fn(point: Vector3, clampToLine?: bool, optionalTarget?: Vector3) -> Vector3",
        "applyMatrix4": "fn(matrix: Matrix4) -> Line3",
        "equals": "fn(line: Line3) -> bool",
        "clone": "fn() -> Line3"
      }
    },
    "Math": {
      "generateUUID": "fn() -> string",
      "clamp": "fn(x: number, a: number, b: number) -> number",
      "clampBottom": "fn(x: number, a: number) -> number",
      "mapLinear": "fn(x: number, a1: number, a2: number, b1: number, b2: number) -> number",
      "smoothstep": "fn(x: number, min: number, max: number) -> number",
      "smootherstep": "fn(x: number, min: number, max: number) -> number",
      "random16": "fn() -> number",
      "randInt": "fn(low: number, high: number) -> number",
      "randFloat": "fn(low: number, high: number) -> number",
      "randFloatSpread": "fn(range: number) -> number",
      "degToRad": "fn(degrees: number) -> number",
      "radToDeg": "fn(radians: number) -> number",
      "isPowerOfTwo": "fn(value: number) -> bool",
      "!type": "Math"
    },
    "Matrix": {
      "elements": "Float32Array",
      "identity": "fn() -> Matrix",
      "copy": "fn(m: Matrix) -> Matrix",
      "multiplyScalar": "fn(s: number) -> Matrix",
      "determinant": "fn() -> number",
      "getInverse": "fn(matrix: Matrix, throwOnInvertible?: bool) -> Matrix",
      "transpose": "fn() -> Matrix",
      "clone": "fn() -> Matrix"
    },
    "Matrix3": {
      "!type": "fn()",
      "prototype": {
        "elements": "Float32Array",
        "set": "fn(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) -> Matrix3",
        "identity": "fn() -> Matrix3",
        "copy": "fn(m: Matrix3) -> Matrix3",
        "applyToVector3Array": "fn(array: [number], offset?: number, length?: number) -> [number]",
        "multiplyScalar": "fn(s: number) -> Matrix3",
        "determinant": "fn() -> number",
        "getInverse": "fn(matrix: Matrix3, throwOnInvertible?: bool) -> Matrix3",
        "transpose": "fn() -> Matrix3",
        "flattenToArrayOffset": "fn(array: [number], offset: number) -> [number]",
        "getNormalMatrix": "fn(m: Matrix4) -> Matrix3",
        "transposeIntoArray": "fn(r: [number]) -> [number]",
        "fromArray": "fn(array: [number]) -> Matrix3",
        "toArray": "fn() -> [number]",
        "clone": "fn() -> Matrix3"
      }
    },
    "Matrix4": {
      "!type": "fn(n11?: number, n12?: number, n13?: number, n14?: number, n21?: number, n22?: number, n23?: number, n24?: number, n31?: number, n32?: number, n33?: number, n34?: number, n41?: number, n42?: number, n43?: number, n44?: number)",
      "prototype": {
        "elements": "Float32Array",
        "set": "fn(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) -> Matrix4",
        "identity": "fn() -> Matrix4",
        "copy": "fn(m: Matrix4) -> Matrix4",
        "copyPosition": "fn(m: Matrix4) -> Matrix4",
        "extractBasis": "fn(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) -> Matrix4",
        "makeBasis": "fn(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) -> Matrix4",
        "extractRotation": "fn(m: Matrix4) -> Matrix4",
        "makeRotationFromEuler": "fn(euler: Euler) -> Matrix4",
        "makeRotationFromQuaternion": "fn(q: Quaternion) -> Matrix4",
        "lookAt": "fn(eye: Vector3, target: Vector3, up: Vector3) -> Matrix4",
        "multiply": "fn(m: Matrix4) -> Matrix4",
        "multiplyMatrices": "fn(a: Matrix4, b: Matrix4) -> Matrix4",
        "multiplyToArray": "fn(a: Matrix4, b: Matrix4, r: [number]) -> Matrix4",
        "multiplyScalar": "fn(s: number) -> Matrix4",
        "applyToVector3Array": "fn(array: [number], offset?: number, length?: number) -> [number]",
        "determinant": "fn() -> number",
        "transpose": "fn() -> Matrix4",
        "flattenToArrayOffset": "fn(array: [number], offset: number) -> [number]",
        "setPosition": "fn(v: Vector3) -> Vector3",
        "getInverse": "fn(m: Matrix4, throwOnInvertible?: bool) -> Matrix4",
        "scale": "fn(v: Vector3) -> Matrix4",
        "getMaxScaleOnAxis": "fn() -> number",
        "makeTranslation": "fn(x: number, y: number, z: number) -> Matrix4",
        "makeRotationX": "fn(theta: number) -> Matrix4",
        "makeRotationY": "fn(theta: number) -> Matrix4",
        "makeRotationZ": "fn(theta: number) -> Matrix4",
        "makeRotationAxis": "fn(axis: Vector3, angle: number) -> Matrix4",
        "makeScale": "fn(x: number, y: number, z: number) -> Matrix4",
        "compose": "fn(translation: Vector3, rotation: Quaternion, scale: Vector3) -> Matrix4",
        "decompose": "fn(translation?: Vector3, rotation?: Quaternion, scale?: Vector3) -> [Object]",
        "makeFrustum": "fn(left: number, right: number, bottom: number, top: number, near: number, far: number) -> Matrix4",
        "makePerspective": "fn(fov: number, aspect: number, near: number, far: number) -> Matrix4",
        "makeOrthographic": "fn(left: number, right: number, top: number, bottom: number, near: number, far: number) -> Matrix4",
        "fromArray": "fn(array: [number]) -> Matrix4",
        "toArray": "fn() -> [number]",
        "clone": "fn() -> Matrix4"
      }
    },
    "Plane": {
      "!type": "fn(normal?: Vector3, constant?: number)",
      "prototype": {
        "normal": "Vector3",
        "constant": "number",
        "set": "fn(normal: Vector3, constant: number) -> Plane",
        "setComponents": "fn(x: number, y: number, z: number, w: number) -> Plane",
        "setFromNormalAndCoplanarPoint": "fn(normal: Vector3, point: Vector3) -> Plane",
        "setFromCoplanarPoints": "fn(a: Vector3, b: Vector3, c: Vector3) -> Plane",
        "copy": "fn(plane: Plane) -> Plane",
        "normalize": "fn() -> Plane",
        "negate": "fn() -> Plane",
        "distanceToPoint": "fn(point: Vector3) -> number",
        "distanceToSphere": "fn(sphere: Sphere) -> number",
        "projectPoint": "fn(point: Vector3, optionalTarget?: Vector3) -> Vector3",
        "orthoPoint": "fn(point: Vector3, optionalTarget?: Vector3) -> Vector3",
        "isIntersectionLine": "fn(line: Line3) -> bool",
        "intersectLine": "fn(line: Line3, optionalTarget?: Vector3) -> Vector3",
        "coplanarPoint": "fn(optionalTarget?: bool) -> Vector3",
        "applyMatrix4": "fn(matrix: Matrix4, optionalNormalMatrix?: Matrix3) -> Plane",
        "translate": "fn(offset: Vector3) -> Plane",
        "equals": "fn(plane: Plane) -> bool",
        "clone": "fn() -> Plane"
      }
    },
    "Quaternion": {
      "!type": "fn(x?: number, y?: number, z?: number, w?: number)",
      "slerp": "fn(qa: Quaternion, qb: Quaternion, qm: Quaternion, t: number) -> Quaternion",
      "prototype": {
        "x": "number",
        "y": "number",
        "z": "number",
        "w": "number",
        "set": "fn(x: number, y: number, z: number, w: number) -> Quaternion",
        "copy": "fn(q: Quaternion) -> Quaternion",
        "setFromEuler": "fn(euler: Euler, update?: bool) -> Quaternion",
        "setFromAxisAngle": "fn(axis: Vector3, angle: number) -> Quaternion",
        "setFromRotationMatrix": "fn(m: Matrix4) -> Quaternion",
        "setFromUnitVectors": "fn(vFrom: Vector3, vTo: Vector3) -> Quaternion",
        "inverse": "fn() -> Quaternion",
        "conjugate": "fn() -> Quaternion",
        "dot": "fn(v: Vector3) -> number",
        "lengthSq": "fn() -> number",
        "length": "fn() -> number",
        "normalize": "fn() -> Quaternion",
        "multiply": "fn(q: Quaternion) -> Quaternion",
        "multiplyQuaternions": "fn(a: Quaternion, b: Quaternion) -> Quaternion",
        "multiplyVector3": "fn(vector: Vector3) -> Vector3",
        "slerp": "fn(qb: Quaternion, t: number) -> Quaternion",
        "equals": "fn(v: Quaternion) -> bool",
        "fromArray": "fn(n: [number]) -> Quaternion",
        "toArray": "fn() -> [number]",
        "onChange": "fn()",
        "clone": "fn() -> Quaternion"
      }
    },
    "Ray": {
      "!type": "fn(origin?: Vector3, direction?: Vector3)",
      "prototype": {
        "origin": "Vector3",
        "direction": "Vector3",
        "set": "fn(origin: Vector3, direction: Vector3) -> Ray",
        "copy": "fn(ray: Ray) -> Ray",
        "at": "fn(t: number, optionalTarget?: Vector3) -> Vector3",
        "recast": "fn(t: number) -> Ray",
        "closestPointToPoint": "fn(point: Vector3, optionalTarget?: Vector3) -> Vector3",
        "distanceToPoint": "fn(point: Vector3) -> number",
        "distanceSqToSegment": "fn(v0: Vector3, v1: Vector3, optionalPointOnRay?: Vector3, optionalPointOnSegment?: Vector3) -> number",
        "isIntersectionSphere": "fn(sphere: Sphere) -> bool",
        "intersectSphere": "fn(sphere: Sphere, optionalTarget?: Vector3) -> Vector3",
        "isIntersectionPlane": "fn(plane: Plane) -> bool",
        "distanceToPlane": "fn(plane: Plane) -> number",
        "intersectPlane": "fn(plane: Plane, optionalTarget?: Vector3) -> Vector3",
        "isIntersectionBox": "fn(box: Box3) -> bool",
        "intersectBox": "fn(box: Box3, optionalTarget?: Vector3) -> Vector3",
        "intersectTriangle": "fn(a: Vector3, b: Vector3, c: Vector3, backfaceCulling: bool, optionalTarget?: Vector3) -> Vector3",
        "applyMatrix4": "fn(matrix4: Matrix4) -> Ray",
        "equals": "fn(ray: Ray) -> bool",
        "clone": "fn() -> Ray"
      }
    },
    "Sphere": {
      "!type": "fn(center?: Vector3, radius?: number)",
      "prototype": {
        "center": "Vector3",
        "radius": "number",
        "set": "fn(center: Vector3, radius: number) -> Sphere",
        "setFromPoints": "fn(points: [Vector3], optionalCenter?: Vector3) -> Sphere",
        "copy": "fn(sphere: Sphere) -> Sphere",
        "empty": "fn() -> bool",
        "containsPoint": "fn(point: Vector3) -> bool",
        "distanceToPoint": "fn(point: Vector3) -> number",
        "intersectsSphere": "fn(sphere: Sphere) -> bool",
        "clampPoint": "fn(point: Vector3, optionalTarget?: Vector3) -> Vector3",
        "getBoundingBox": "fn(optionalTarget?: Box3) -> Box3",
        "applyMatrix4": "fn(matrix: Matrix4) -> Sphere",
        "translate": "fn(offset: Vector3) -> Sphere",
        "equals": "fn(sphere: Sphere) -> bool",
        "clone": "fn() -> Sphere"
      }
    },
    "SplineControlPoint": {
      "x": "number",
      "y": "number",
      "z": "number"
    },
    "Spline": {
      "!type": "fn(points: [SplineControlPoint])",
      "prototype": {
        "points": "[SplineControlPoint]",
        "initFromArray": "fn(a: [[number]])",
        "getPoint": "fn(k: number) -> SplineControlPoint",
        "getControlPointsArray": "fn() -> [[number]]",
        "getLength": "fn(nSubDivisions?: number) -> ret1",
        "reparametrizeByArcLength": "fn(samplingCoef: number)"
      }
    },
    "Triangle": {
      "!type": "fn(a?: Vector3, b?: Vector3, c?: Vector3)",
      "normal": "fn(a: Vector3, b: Vector3, c: Vector3, optionalTarget?: Vector3) -> Vector3",
      "barycoordFromPoint": "fn(point: Vector3, a: Vector3, b: Vector3, c: Vector3, optionalTarget: Vector3) -> Vector3",
      "containsPoint": "fn(point: Vector3, a: Vector3, b: Vector3, c: Vector3) -> bool",
      "prototype": {
        "a": "Vector3",
        "b": "Vector3",
        "c": "Vector3",
        "set": "fn(a: Vector3, b: Vector3, c: Vector3) -> Triangle",
        "setFromPointsAndIndices": "fn(points: [Vector3], i0: number, i1: number, i2: number) -> Triangle",
        "copy": "fn(triangle: Triangle) -> Triangle",
        "area": "fn() -> number",
        "midpoint": "fn(optionalTarget?: Vector3) -> Vector3",
        "normal": "fn(optionalTarget?: Vector3) -> Vector3",
        "plane": "fn(optionalTarget?: Vector3) -> Plane",
        "barycoordFromPoint": "fn(point: Vector3, optionalTarget?: Vector3) -> Vector3",
        "containsPoint": "fn(point: Vector3) -> bool",
        "equals": "fn(triangle: Triangle) -> bool",
        "clone": "fn() -> Triangle"
      }
    },
    "Vector": {
      "setComponent": "fn(index: number, value: number)",
      "getComponent": "fn(index: number) -> number",
      "copy": "fn(v: Vector) -> Vector",
      "add": "fn(v: Vector) -> Vector",
      "addVectors": "fn(a: Vector, b: Vector) -> Vector",
      "sub": "fn(v: Vector) -> Vector",
      "subVectors": "fn(a: Vector, b: Vector) -> Vector",
      "multiplyScalar": "fn(s: number) -> Vector",
      "divideScalar": "fn(s: number) -> Vector",
      "negate": "fn() -> Vector",
      "dot": "fn(v: Vector) -> number",
      "lengthSq": "fn() -> number",
      "length": "fn() -> number",
      "normalize": "fn() -> Vector",
      "distanceTo": "fn(v: Vector) -> number",
      "distanceToSquared": "fn(v: Vector) -> number",
      "setLength": "fn(l: number) -> Vector",
      "lerp": "fn(v: Vector, alpha: number) -> Vector",
      "equals": "fn(v: Vector) -> bool",
      "clone": "fn() -> Vector"
    },
    "Vector2": {
      "!type": "fn(x?: number, y?: number)",
      "prototype": {
        "x": "number",
        "y": "number",
        "set": "fn(x: number, y: number) -> Vector2",
        "setX": "fn(x: number) -> Vector2",
        "setY": "fn(y: number) -> Vector2",
        "setComponent": "fn(index: number, value: number)",
        "getComponent": "fn(index: number) -> number",
        "copy": "fn(v: Vector2) -> Vector2",
        "add": "fn(v: Vector2) -> Vector2",
        "addVectors": "fn(a: Vector2, b: Vector2) -> Vector2",
        "addScalar": "fn(s: number) -> Vector2",
        "sub": "fn(v: Vector2) -> Vector2",
        "subVectors": "fn(a: Vector2, b: Vector2) -> Vector2",
        "multiply": "fn(v: Vector2) -> Vector2",
        "multiplyScalar": "fn(s: number) -> Vector2",
        "divide": "fn(v: Vector2) -> Vector2",
        "divideScalar": "fn(s: number) -> Vector2",
        "min": "fn(v: Vector2) -> Vector2",
        "max": "fn(v: Vector2) -> Vector2",
        "clamp": "fn(min: Vector2, max: Vector2) -> Vector2",
        "clampScalar": "fn(min: number, max: number) -> Vector2",
        "floor": "fn() -> Vector2",
        "ceil": "fn() -> Vector2",
        "round": "fn() -> Vector2",
        "roundToZero": "fn() -> Vector2",
        "negate": "fn() -> Vector2",
        "dot": "fn(v: Vector2) -> number",
        "lengthSq": "fn() -> number",
        "length": "fn() -> number",
        "normalize": "fn() -> Vector2",
        "distanceTo": "fn(v: Vector2) -> number",
        "distanceToSquared": "fn(v: Vector2) -> number",
        "setLength": "fn(l: number) -> Vector2",
        "lerp": "fn(v: Vector2, alpha: number) -> Vector2",
        "equals": "fn(v: Vector2) -> bool",
        "fromArray": "fn(xy: [number], offset?: number) -> Vector2",
        "toArray": "fn(xy?: [number], offset?: number) -> [number]",
        "fromAttribute": "fn(attribute: BufferAttribute, index: number, offset?: number) -> Vector2",
        "clone": "fn() -> Vector2"
      }
    },
    "Vector3": {
      "!type": "fn(x?: number, y?: number, z?: number)",
      "prototype": {
        "x": "number",
        "y": "number",
        "z": "number",
        "set": "fn(x: number, y: number, z: number) -> Vector3",
        "setX": "fn(x: number) -> Vector3",
        "setY": "fn(y: number) -> Vector3",
        "setZ": "fn(z: number) -> Vector3",
        "setComponent": "fn(index: number, value: number)",
        "getComponent": "fn(index: number) -> number",
        "copy": "fn(v: Vector3) -> Vector3",
        "add": "fn(a: Vector3) -> Vector3",
        "addScalar": "fn(s: number) -> Vector3",
        "addVectors": "fn(a: Vector3, b: Vector3) -> Vector3",
        "sub": "fn(a: Vector3) -> Vector3",
        "subVectors": "fn(a: Vector3, b: Vector3) -> Vector3",
        "multiply": "fn(v: Vector3) -> Vector3",
        "multiplyScalar": "fn(s: number) -> Vector3",
        "multiplyVectors": "fn(a: Vector3, b: Vector3) -> Vector3",
        "applyEuler": "fn(euler: Euler) -> Vector3",
        "applyAxisAngle": "fn(axis: Vector3, angle: number) -> Vector3",
        "applyMatrix3": "fn(m: Matrix3) -> Vector3",
        "applyMatrix4": "fn(m: Matrix4) -> Vector3",
        "applyProjection": "fn(m: Matrix4) -> Vector3",
        "applyQuaternion": "fn(q: Quaternion) -> Vector3",
        "project": "fn(camrea: Camera) -> Vector3",
        "unproject": "fn(camera: Camera) -> Vector3",
        "transformDirection": "fn(m: Matrix4) -> Vector3",
        "divide": "fn(v: Vector3) -> Vector3",
        "divideScalar": "fn(s: number) -> Vector3",
        "min": "fn(v: Vector3) -> Vector3",
        "max": "fn(v: Vector3) -> Vector3",
        "clamp": "fn(min: Vector3, max: Vector3) -> Vector3",
        "clampScalar": "fn(min: number, max: number) -> Vector3",
        "floor": "fn() -> Vector3",
        "ceil": "fn() -> Vector3",
        "round": "fn() -> Vector3",
        "roundToZero": "fn() -> Vector3",
        "negate": "fn() -> Vector3",
        "dot": "fn(v: Vector3) -> number",
        "lengthSq": "fn() -> number",
        "length": "fn() -> number",
        "lengthManhattan": "fn() -> number",
        "normalize": "fn() -> Vector3",
        "setLength": "fn(l: number) -> Vector3",
        "lerp": "fn(v: Vector3, alpha: number) -> Vector3",
        "cross": "fn(a: Vector3) -> Vector3",
        "crossVectors": "fn(a: Vector3, b: Vector3) -> Vector3",
        "projectOnVector": "fn(v: Vector3) -> Vector3",
        "projectOnPlane": "fn(planeNormal: Vector3) -> Vector3",
        "reflect": "fn(vector: Vector3) -> Vector3",
        "angleTo": "fn(v: Vector3) -> number",
        "distanceTo": "fn(v: Vector3) -> number",
        "distanceToSquared": "fn(v: Vector3) -> number",
        "setFromMatrixPosition": "fn(m: Matrix4) -> Vector3",
        "setFromMatrixScale": "fn(m: Matrix4) -> Vector3",
        "setFromMatrixColumn": "fn(index: number, matrix: Matrix4) -> Vector3",
        "equals": "fn(v: Vector3) -> bool",
        "fromArray": "fn(xyz: [number], offset?: number) -> Vector3",
        "toArray": "fn(xyz?: [number], offset?: number) -> [number]",
        "fromAttribute": "fn(attribute: BufferAttribute, index: number, offset?: number) -> Vector3",
        "clone": "fn() -> Vector3"
      }
    },
    "Vector4": {
      "!type": "fn(x?: number, y?: number, z?: number, w?: number)",
      "prototype": {
        "x": "number",
        "y": "number",
        "z": "number",
        "w": "number",
        "set": "fn(x: number, y: number, z: number, w: number) -> Vector4",
        "setX": "fn(x: number) -> Vector4",
        "setY": "fn(y: number) -> Vector4",
        "setZ": "fn(z: number) -> Vector4",
        "setW": "fn(w: number) -> Vector4",
        "setComponent": "fn(index: number, value: number)",
        "getComponent": "fn(index: number) -> number",
        "copy": "fn(v: Vector4) -> Vector4",
        "add": "fn(v: Vector4) -> Vector4",
        "addScalar": "fn(s: number) -> Vector4",
        "addVectors": "fn(a: Vector4, b: Vector4) -> Vector4",
        "sub": "fn(v: Vector4) -> Vector4",
        "subVectors": "fn(a: Vector4, b: Vector4) -> Vector4",
        "multiplyScalar": "fn(s: number) -> Vector4",
        "applyMatrix4": "fn(m: Matrix4) -> Vector4",
        "divideScalar": "fn(s: number) -> Vector4",
        "setAxisAngleFromQuaternion": "fn(q: Quaternion) -> Vector4",
        "setAxisAngleFromRotationMatrix": "fn(m: Matrix3) -> Vector4",
        "min": "fn(v: Vector4) -> Vector4",
        "max": "fn(v: Vector4) -> Vector4",
        "clamp": "fn(min: Vector4, max: Vector4) -> Vector4",
        "clampScalar": "fn(min: number, max: number) -> Vector4",
        "floor": "fn() -> Vector4",
        "ceil": "fn() -> Vector4",
        "round": "fn() -> Vector4",
        "roundToZero": "fn() -> Vector4",
        "negate": "fn() -> Vector4",
        "dot": "fn(v: Vector4) -> number",
        "lengthSq": "fn() -> number",
        "length": "fn() -> number",
        "lengthManhattan": "fn() -> number",
        "normalize": "fn() -> Vector4",
        "setLength": "fn(l: number) -> Vector4",
        "lerp": "fn(v: Vector4, alpha: number) -> Vector4",
        "equals": "fn(v: Vector4) -> bool",
        "fromArray": "fn(xyzw: [number], offset?: number) -> Vector4",
        "toArray": "fn(xyzw?: [number], offset?: number) -> [number]",
        "fromAttribute": "fn(attribute: BufferAttribute, index: number, offset?: number) -> Vector4",
        "clone": "fn() -> Vector4"
      }
    },
    "Bone": {
      "!type": "fn(belongsToSkin: SkinnedMesh)",
      "prototype": {
        "skin": "SkinnedMesh"
      }
    },
    "Group": {
      "!type": "fn()",
      "prototype": {}
    },
    "LensFlareProperty": {
      "texture": "Texture",
      "size": "number",
      "distance": "number",
      "x": "number",
      "y": "number",
      "z": "number",
      "scale": "number",
      "rotation": "number",
      "opacity": "number",
      "color": "Color",
      "blending": "Blending"
    },
    "LensFlare": {
      "!type": "fn(texture?: Texture, size?: number, distance?: number, blending?: Blending, color?: Color)",
      "prototype": {
        "lensFlares": "[LensFlareProperty]",
        "positionScreen": "Vector3",
        "customUpdateCallback": "fn(object: LensFlare)",
        "add": "fn(texture: Texture, size?: number, distance?: number, blending?: Blending, color?: Color)",
        "updateLensFlares": "fn()"
      }
    },
    "Line": {
      "!type": "fn(geometry?: Geometry, material?: LineDashedMaterial, mode?: number)",
      "prototype": {
        "geometry": "?",
        "material": "Material",
        "mode": "LineMode",
        "raycast": "fn(raycaster: Raycaster, intersects: ?)",
        "clone": "fn(object?: Line) -> Line"
      }
    },
    "LineMode": "number",
    "LineStrip": "LineMode",
    "LinePieces": "LineMode",
    "LOD": {
      "!type": "fn()",
      "prototype": {
        "objects": "[?]",
        "addLevel": "fn(object: Object3D, distance?: number)",
        "getObjectForDistance": "fn(distance: number) -> Object3D",
        "raycast": "fn(raycaster: Raycaster, intersects: ?)",
        "update": "fn(camera: Camera)",
        "clone": "fn(object?: LOD) -> LOD"
      }
    },
    "Mesh": {
      "!type": "fn(geometry?: Geometry, material?: Material)",
      "prototype": {
        "geometry": "Geometry",
        "material": "Material",
        "updateMorphTargets": "fn()",
        "getMorphTargetIndexByName": "fn(name: string) -> number",
        "raycast": "fn(raycaster: Raycaster, intersects: ?)",
        "clone": "fn(object?: Mesh) -> Mesh"
      }
    },
    "MorphAnimMesh": {
      "!type": "fn(geometry?: Geometry, material?: MeshBasicMaterial)",
      "prototype": {
        "duration": "number",
        "mirroredLoop": "bool",
        "time": "number",
        "lastKeyframe": "number",
        "currentKeyframe": "number",
        "direction": "number",
        "directionBackwards": "bool",
        "startKeyframe": "number",
        "endKeyframe": "number",
        "length": "number",
        "setFrameRange": "fn(start: number, end: number)",
        "setDirectionForward": "fn()",
        "setDirectionBackward": "fn()",
        "parseAnimations": "fn()",
        "setAnimationLabel": "fn(label: string, start: number, end: number)",
        "playAnimation": "fn(label: string, fps: number)",
        "updateAnimation": "fn(delta: number)",
        "interpolateTargets": "fn(a: number, b: number, t: number)",
        "clone": "fn(object?: MorphAnimMesh) -> MorphAnimMesh"
      }
    },
    "PointCloud": {
      "!type": "fn(geometry: Geometry, material?: PointCloudMaterial)",
      "prototype": {
        "geometry": "Geometry",
        "material": "Material",
        "raycast": "fn(raycaster: Raycaster, intersects: ?)",
        "clone": "fn(object?: PointCloud) -> PointCloud"
      }
    },
    "Skeleton": {
      "!type": "fn(bones: [Bone], boneInverses?: [Matrix4], useVertexTexture?: bool)",
      "prototype": {
        "useVertexTexture": "bool",
        "identityMatrix": "Matrix4",
        "bones": "[Bone]",
        "boneTextureWidth": "number",
        "boneTextureHeight": "number",
        "boneMatrices": "Float32Array",
        "boneTexture": "DataTexture",
        "boneInverses": "[Matrix4]",
        "calculateInverses": "fn(bone: Bone)",
        "pose": "fn()",
        "update": "fn()"
      }
    },
    "SkinnedMesh": {
      "!type": "fn(geometry?: Geometry, material?: MeshBasicMaterial, useVertexTexture?: bool)",
      "prototype": {
        "bindMode": "string",
        "bindMatrix": "Matrix4",
        "bindMatrixInverse": "Matrix4",
        "bind": "fn(skeleton: Skeleton, bindMatrix?: Matrix4)",
        "pose": "fn()",
        "normalizeSkinWeights": "fn()",
        "updateMatrixWorld": "fn(force?: bool)",
        "clone": "fn(object?: SkinnedMesh) -> SkinnedMesh",
        "skeleton": "Skeleton"
      }
    },
    "Sprite": {
      "!type": "fn(material?: Material)",
      "prototype": {
        "geometry": "BufferGeometry",
        "material": "SpriteMaterial",
        "raycast": "fn(raycaster: Raycaster, intersects: ?)",
        "clone": "fn(object?: Sprite) -> Sprite"
      }
    },
    "Renderer": {
      "render": "fn(scene: Scene, camera: Camera)",
      "setSize": "fn(width: number, height: number, updateStyle?: bool)",
      "domElement": "HTMLCanvasElement"
    },
    "WebGLRendererParameters": {
      "canvas": "HTMLCanvasElement",
      "precision": "string",
      "alpha": "bool",
      "premultipliedAlpha": "bool",
      "antialias": "bool",
      "stencil": "bool",
      "preserveDrawingBuffer": "bool",
      "clearColor": "number",
      "clearAlpha": "number",
      "devicePixelRatio": "number"
    },
    "WebGLRenderer": {
      "!type": "fn(parameters?: WebGLRendererParameters)",
      "prototype": {
        "domElement": "HTMLCanvasElement",
        "context": "?",
        "autoClear": "bool",
        "autoClearColor": "bool",
        "autoClearDepth": "bool",
        "autoClearStencil": "bool",
        "sortObjects": "bool",
        "gammaInput": "bool",
        "gammaOutput": "bool",
        "shadowMapEnabled": "bool",
        "shadowMapType": "ShadowMapType",
        "shadowMapCullFace": "CullFace",
        "shadowMapDebug": "bool",
        "shadowMapCascade": "bool",
        "maxMorphTargets": "number",
        "maxMorphNormals": "number",
        "autoScaleCubemaps": "bool",
        "info": {
          "memory": {
            "programs": "number",
            "geometries": "number",
            "textures": "number"
          },
          "render": {
            "calls": "number",
            "vertices": "number",
            "faces": "number",
            "points": "number"
          }
        },
        "shadowMapPlugin": "ShadowMapPlugin",
        "getContext": "fn() -> WebGLRenderingContext",
        "forceContextLoss": "fn()",
        "supportsVertexTextures": "fn() -> bool",
        "supportsFloatTextures": "fn() -> bool",
        "supportsStandardDerivatives": "fn() -> bool",
        "supportsCompressedTextureS3TC": "fn() -> bool",
        "supportsCompressedTexturePVRTC": "fn() -> bool",
        "supportsBlendMinMax": "fn() -> bool",
        "getMaxAnisotropy": "fn() -> number",
        "getPrecision": "fn() -> string",
        "getPixelRatio": "fn() -> number",
        "setPixelRatio": "fn(value: number)",
        "setSize": "fn(width: number, height: number, updateStyle?: bool)",
        "setViewport": "fn(x?: number, y?: number, width?: number, height?: number)",
        "setScissor": "fn(x: number, y: number, width: number, height: number)",
        "enableScissorTest": "fn(enable: bool)",
        "setClearColor": "fn(color: Color, alpha?: number)",
        "setClearAlpha": "fn(alpha: number)",
        "setClearColorHex": "fn(hex: number, alpha: number)",
        "getClearColor": "fn() -> Color",
        "getClearAlpha": "fn() -> number",
        "clear": "fn(color?: bool, depth?: bool, stencil?: bool)",
        "clearColor": "fn()",
        "clearDepth": "fn()",
        "clearStencil": "fn()",
        "clearTarget": "fn(renderTarget: WebGLRenderTarget, color: bool, depth: bool, stencil: bool)",
        "resetGLState": "fn()",
        "updateShadowMap": "fn(scene: Scene, camera: Camera)",
        "renderBufferImmediate": "fn(object: Object3D, program: Object, material: Material)",
        "renderBufferDirect": "fn(camera: Camera, lights: [Light], fog: Fog, material: Material, geometryGroup: ?, object: Object3D)",
        "renderBuffer": "fn(camera: Camera, lights: [Light], fog: Fog, material: Material, geometryGroup: ?, object: Object3D)",
        "render": "fn(scene: Scene, camera: Camera, renderTarget?: RenderTarget, forceClear?: bool)",
        "renderImmediateObject": "fn(camera: Camera, lights: [Light], fog: Fog, material: Material, object: Object3D)",
        "setFaceCulling": "fn(cullFace?: CullFace, frontFace?: FrontFaceDirection)",
        "setMaterialFaces": "fn(material: Material)",
        "setDepthTest": "fn(depthTest: bool)",
        "setDepthWrite": "fn(depthWrite: bool)",
        "setBlending": "fn(blending: Blending, blendEquation: BlendingEquation, blendSrc: BlendingSrcFactor, blendDst: BlendingDstFactor)",
        "uploadTexture": "fn(texture: Texture)",
        "setTexture": "fn(texture: Texture, slot: number)",
        "setRenderTarget": "fn(renderTarget: RenderTarget)"
      }
    },
    "RenderTarget": {},
    "WebGLRenderTargetOptions": {
      "wrapS": "Wrapping",
      "wrapT": "Wrapping",
      "magFilter": "TextureFilter",
      "minFilter": "TextureFilter",
      "anisotropy": "number",
      "format": "number",
      "type": "TextureDataType",
      "depthBuffer": "bool",
      "stencilBuffer": "bool"
    },
    "WebGLRenderTarget": {
      "!type": "fn(width: number, height: number, options?: WebGLRenderTargetOptions)",
      "prototype": {
        "width": "number",
        "height": "number",
        "wrapS": "Wrapping",
        "wrapT": "Wrapping",
        "magFilter": "TextureFilter",
        "minFilter": "TextureFilter",
        "anisotropy": "number",
        "offset": "Vector2",
        "repeat": "Vector2",
        "format": "number",
        "type": "number",
        "depthBuffer": "bool",
        "stencilBuffer": "bool",
        "generateMipmaps": "bool",
        "shareDepthFrom": "?",
        "clone": "fn() -> WebGLRenderTarget",
        "dispose": "fn()",
        "addEventListener": "fn(type: string, listener: fn(event: ?))",
        "hasEventListener": "fn(type: string, listener: fn(event: ?))",
        "removeEventListener": "fn(type: string, listener: fn(event: ?))",
        "dispatchEvent": "fn(event: [object Object])"
      }
    },
    "WebGLRenderTargetCube": {
      "!type": "fn(width: number, height: number, options?: WebGLRenderTargetOptions)",
      "prototype": {
        "activeCubeFace": "number"
      }
    },
    "ShaderChunk": {
      "alphamap_fragment": "string",
      "alphamap_pars_fragment": "string",
      "alphatest_fragment": "string",
      "bumpmap_pars_fragment": "string",
      "color_fragment": "string",
      "color_pars_fragment": "string",
      "color_pars_vertex": "string",
      "color_vertex": "string",
      "default_vertex": "string",
      "defaultnormal_vertex": "string",
      "envmap_fragment": "string",
      "envmap_pars_fragment": "string",
      "envmap_pars_vertex": "string",
      "envmap_vertex": "string",
      "fog_fragment": "string",
      "fog_pars_fragment": "string",
      "lightmap_fragment": "string",
      "lightmap_pars_fragment": "string",
      "lightmap_pars_vertex": "string",
      "lightmap_vertex": "string",
      "lights_lambert_pars_vertex": "string",
      "lights_lambert_vertex": "string",
      "lights_phong_fragment": "string",
      "lights_phong_pars_fragment": "string",
      "lights_phong_pars_vertex": "string",
      "lights_phong_vertex": "string",
      "linear_to_gamma_fragment": "string",
      "logdepthbuf_fragment": "string",
      "logdepthbuf_pars_fragment": "string",
      "logdepthbuf_pars_vertex": "string",
      "logdepthbuf_vertex": "string",
      "map_fragment": "string",
      "map_pars_fragment": "string",
      "map_pars_vertex": "string",
      "map_particle_fragment": "string",
      "map_particle_pars_fragment": "string",
      "map_vertex": "string",
      "morphnormal_vertex": "string",
      "morphtarget_pars_vertex": "string",
      "morphtarget_vertex": "string",
      "normalmap_pars_fragment": "string",
      "shadowmap_fragment": "string",
      "shadowmap_pars_fragment": "string",
      "shadowmap_pars_vertex": "string",
      "shadowmap_vertex": "string",
      "skinbase_vertex": "string",
      "skinning_pars_vertex": "string",
      "skinning_vertex": "string",
      "skinnormal_vertex": "string",
      "specularmap_fragment": "string",
      "specularmap_pars_fragment": "string",
      "worldpos_vertex": "string",
      "!type": "ShaderChunk"
    },
    "Shader": {
      "uniforms": "?",
      "vertexShader": "string",
      "fragmentShader": "string"
    },
    "ShaderLib": {
      "basic": "Shader",
      "lambert": "Shader",
      "phong": "Shader",
      "particle_basic": "Shader",
      "dashed": "Shader",
      "depth": "Shader",
      "normal": "Shader",
      "normalmap": "Shader",
      "cube": "Shader",
      "depthRGBA": "Shader"
    },
    "UniformsLib": {
      "common": "?",
      "bump": "?",
      "normalmap": "?",
      "fog": "?",
      "lights": "?",
      "particle": "?",
      "shadowmap": "?"
    },
    "UniformsUtils": {
      "merge": "fn(uniforms: [?]) -> ?",
      "clone": "fn(uniforms_src: ?) -> ?"
    },
    "WebGLExtensions": {
      "!type": "fn(gl: ?)",
      "prototype": {
        "get": "fn(name: string) -> ?"
      }
    },
    "WebGLProgram": {
      "!type": "fn(renderer: WebGLRenderer, code: string, material: ShaderMaterial, parameters: WebGLRendererParameters)",
      "prototype": {
        "attributes": "?",
        "attributesKeys": "[string]",
        "id": "number",
        "code": "string",
        "usedTimes": "number",
        "program": "?",
        "vertexShader": "WebGLShader",
        "fragmentShader": "WebGLShader"
      }
    },
    "WebGLShader": {
      "!type": "fn(gl: ?, type: string, string: string)",
      "prototype": {}
    },
    "RendererPlugin": {
      "init": "fn(renderer: WebGLRenderer)",
      "render": "fn(scene: Scene, camera: Camera, currentWidth: number, currentHeight: number)"
    },
    "LensFlarePlugin": {
      "!type": "fn()",
      "prototype": {
        "init": "fn(renderer: Renderer)",
        "render": "fn(scene: Scene, camera: Camera, viewportWidth: number, viewportHeight: number)"
      }
    },
    "ShadowMapPlugin": {
      "!type": "fn()",
      "prototype": {
        "init": "fn(renderer: Renderer)",
        "render": "fn(scene: Scene, camera: Camera)",
        "update": "fn(scene: Scene, camera: Camera)"
      }
    },
    "SpritePlugin": {
      "!type": "fn()",
      "prototype": {
        "init": "fn(renderer: Renderer)",
        "render": "fn(scene: Scene, camera: Camera, viewportWidth: number, viewportHeight: number)"
      }
    },
    "IFog": {
      "name": "string",
      "color": "Color",
      "clone": "fn() -> IFog"
    },
    "Fog": {
      "!type": "fn(hex: number, near?: number, far?: number)",
      "prototype": {
        "name": "string",
        "color": "Color",
        "near": "number",
        "far": "number",
        "clone": "fn() -> Fog"
      }
    },
    "FogExp2": {
      "!type": "fn(hex: number, density?: number)",
      "prototype": {
        "name": "string",
        "color": "Color",
        "density": "number",
        "clone": "fn() -> FogExp2"
      }
    },
    "Scene": {
      "!type": "fn()",
      "prototype": {
        "fog": "IFog",
        "overrideMaterial": "Material",
        "autoUpdate": "bool",
        "clone": "fn() -> Scene"
      }
    },
    "CompressedTexture": {
      "!type": "fn(mipmaps: [ImageData], width: number, height: number, format?: PixelFormat, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, anisotropy?: number)",
      "prototype": {
        "image": {
          "width": "number",
          "height": "number"
        },
        "mipmaps": "[ImageData]",
        "flipY": "bool",
        "generateMipmaps": "bool",
        "clone": "fn() -> CompressedTexture"
      }
    },
    "CubeTexture": {
      "!type": "fn(images: [?], mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number)",
      "prototype": {
        "images": "[?]",
        "clone": "fn(texture?: CubeTexture) -> CubeTexture"
      }
    },
    "DataTexture": {
      "!type": "fn(data: ImageData, width: number, height: number, format: PixelFormat, type: TextureDataType, mapping: Mapping, wrapS: Wrapping, wrapT: Wrapping, magFilter: TextureFilter, minFilter: TextureFilter, anisotropy?: number)",
      "prototype": {
        "image": {
          "data": "ImageData",
          "width": "number",
          "height": "number"
        },
        "clone": "fn() -> DataTexture"
      }
    },
    "Texture": {
      "!type": "fn(image: ?, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number)",
      "DEFAULT_IMAGE": "?",
      "DEFAULT_MAPPING": "?",
      "prototype": {
        "id": "number",
        "uuid": "string",
        "name": "string",
        "image": "?",
        "mipmaps": "[ImageData]",
        "mapping": "Mapping",
        "wrapS": "Wrapping",
        "wrapT": "Wrapping",
        "magFilter": "TextureFilter",
        "minFilter": "TextureFilter",
        "anisotropy": "number",
        "format": "PixelFormat",
        "type": "TextureDataType",
        "offset": "Vector2",
        "repeat": "Vector2",
        "generateMipmaps": "bool",
        "premultiplyAlpha": "bool",
        "flipY": "bool",
        "unpackAlignment": "number",
        "needsUpdate": "bool",
        "onUpdate": "fn()",
        "clone": "fn() -> Texture",
        "update": "fn()",
        "dispose": "fn()",
        "addEventListener": "fn(type: string, listener: fn(event: ?))",
        "hasEventListener": "fn(type: string, listener: fn(event: ?))",
        "removeEventListener": "fn(type: string, listener: fn(event: ?))",
        "dispatchEvent": "fn(event: [object Object])"
      }
    },
    "VideoTexture": {
      "!type": "fn(video: HTMLVideoElement, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number)",
      "prototype": {
        "generateMipmaps": "bool"
      }
    },
    "TypefaceData": {
      "familyName": "string",
      "cssFontWeight": "string",
      "cssFontStyle": "string"
    },
    "FontUtils": {
      "faces": {},
      "face": "string",
      "weight": "string",
      "style": "string",
      "size": "number",
      "divisions": "number",
      "getFace": "fn() -> Face3",
      "loadFace": "fn(data: TypefaceData) -> TypefaceData",
      "drawText": "fn(text: string) -> ret2",
      "extractGlyphPoints": "fn(c: string, face: Face3, scale: number, offset: number, path: Path) -> ret3",
      "generateShapes": "fn(text: string, parameters?: [object Object]) -> [Shape]",
      "Triangulate": {
        "area": "fn(contour: [Vector2]) -> number"
      }
    },
    "GeometryUtils": {
      "merge": "fn(geometry1: Geometry, object2: Mesh, materialIndexOffset?: number)",
      "center": "fn(geometry: Geometry) -> Vector3"
    },
    "ImageUtils": {
      "crossOrigin": "string",
      "loadTexture": "fn(url: string, mapping?: Mapping, onLoad?: fn(texture: Texture), onError?: fn(message: string)) -> Texture",
      "loadTextureCube": "fn(array: [string], mapping?: Mapping, onLoad?: fn(texture: Texture), onError?: fn(message: string)) -> Texture",
      "getNormalMap": "fn(image: HTMLImageElement, depth?: number) -> HTMLCanvasElement",
      "generateDataTexture": "fn(width: number, height: number, color: Color) -> DataTexture"
    },
    "SceneUtils": {
      "createMultiMaterialObject": "fn(geometry: Geometry, materials: [Material]) -> Object3D",
      "detach": "fn(child: Object3D, parent: Object3D, scene: Scene)",
      "attach": "fn(child: Object3D, scene: Scene, parent: Object3D)"
    },
    "KeyFrame": {
      "pos": "[number]",
      "rot": "[number]",
      "scl": "[number]",
      "time": "number"
    },
    "KeyFrames": {
      "keys": "[KeyFrame]",
      "parent": "number"
    },
    "AnimationData": {
      "JIT": "number",
      "fps": "number",
      "hierarchy": "[KeyFrames]",
      "length": "number",
      "name": "string"
    },
    "Animation": {
      "!type": "fn(root: Mesh, data: AnimationData)",
      "prototype": {
        "root": "Mesh",
        "data": "AnimationData",
        "hierarchy": "[Bone]",
        "currentTime": "number",
        "timeScale": "number",
        "isPlaying": "bool",
        "loop": "bool",
        "weight": "number",
        "keyTypes": "[string]",
        "interpolationType": "number",
        "play": "fn(startTime?: number, weight?: number)",
        "stop": "fn()",
        "reset": "fn()",
        "resetBlendWeights": "fn()",
        "update": "fn(deltaTimeMS: number)",
        "getNextKeyWith": "fn(type: string, h: number, key: number) -> KeyFrame",
        "getPrevKeyWith": "fn(type: string, h: number, key: number) -> KeyFrame"
      }
    },
    "AnimationHandler": {
      "LINEAR": "number",
      "CATMULLROM": "number",
      "CATMULLROM_FORWARD": "number",
      "animations": "[?]",
      "init": "fn(data: AnimationData) -> AnimationData",
      "parse": "fn(root: Mesh) -> [Object3D]",
      "play": "fn(animation: Animation)",
      "stop": "fn(animation: Animation)",
      "update": "fn(deltaTimeMS: number)"
    },
    "KeyFrameAnimation": {
      "!type": "fn(data: ?)",
      "prototype": {
        "root": "Mesh",
        "data": "Object",
        "hierarchy": "[KeyFrames]",
        "currentTime": "number",
        "timeScale": "number",
        "isPlaying": "bool",
        "isPaused": "bool",
        "loop": "bool",
        "play": "fn(startTime?: number)",
        "stop": "fn()",
        "update": "fn(delta: number)",
        "getNextKeyWith": "fn(type: string, h: number, key: number) -> KeyFrame",
        "getPrevKeyWith": "fn(type: string, h: number, key: number) -> KeyFrame"
      }
    },
    "MorphAnimation": {
      "!type": "fn(mesh: Mesh)",
      "prototype": {
        "mesh": "Mesh",
        "frames": "number",
        "currentTime": "number",
        "duration": "number",
        "loop": "bool",
        "lastFrame": "number",
        "currentFrame": "number",
        "isPlaying": "bool",
        "play": "fn()",
        "pause": "fn()",
        "update": "fn(deltaTimeMS: number)"
      }
    },
    "Audio": {
      "!type": "fn(listener: AudioListener)",
      "prototype": {
        "type": "string",
        "context": "AudioContext",
        "source": "AudioBufferSourceNode",
        "gain": "GainNode",
        "panner": "PannerNode",
        "load": "fn(file: string) -> Audio",
        "setLoop": "fn(value: bool)",
        "setRefDistance": "fn(value: number)",
        "setRolloffFactor": "fn(value: number)",
        "updateMatrixWorld": "fn(force?: bool)"
      }
    },
    "AudioListener": {
      "!type": "fn()",
      "prototype": {
        "type": "string",
        "context": "AudioContext",
        "updateMatrixWorld": "fn(force?: bool)"
      }
    },
    "Curve": {
      "Utils": {
        "tangentQuadraticBezier": "fn(t: number, p0: number, p1: number, p2: number) -> number",
        "tangentCubicBezier": "fn(t: number, p0: number, p1: number, p2: number, p3: number) -> number",
        "tangentSpline": "fn(t: number, p0: number, p1: number, p2: number, p3: number) -> number",
        "interpolate": "fn(p0: number, p1: number, p2: number, p3: number, t: number) -> number"
      },
      "create": "fn(constructorFunc: Function, getPointFunc: Function) -> Function",
      "prototype": {
        "getPoint": "fn(t: number) -> T",
        "getPointAt": "fn(u: number) -> T",
        "getPoints": "fn(divisions?: number) -> [T]",
        "getSpacedPoints": "fn(divisions?: number) -> [T]",
        "getLength": "fn() -> number",
        "getLengths": "fn(divisions?: number) -> [number]",
        "updateArcLengths": "fn()",
        "getUtoTmapping": "fn(u: number, distance: number) -> number",
        "getTangent": "fn(t: number) -> T",
        "getTangentAt": "fn(u: number) -> T"
      }
    },
    "BoundingBox": {
      "minX": "number",
      "minY": "number",
      "minZ": "number",
      "maxX": "number",
      "maxY": "number",
      "maxZ": "number"
    },
    "CurvePath": {
      "!type": "fn()",
      "prototype": {
        "curves": "[?]",
        "bends": "[Path]",
        "autoClose": "bool",
        "add": "fn(curve: ?)",
        "checkConnection": "fn() -> bool",
        "closePath": "fn()",
        "getLength": "fn() -> number",
        "getCurveLengths": "fn() -> [number]",
        "getBoundingBox": "fn() -> BoundingBox",
        "createPointsGeometry": "fn(divisions: number) -> Geometry",
        "createSpacedPointsGeometry": "fn(divisions: number) -> Geometry",
        "createGeometry": "fn(points: [T]) -> Geometry",
        "addWrapPath": "fn(bendpath: Path)",
        "getTransformedPoints": "fn(segments: number, bends?: [Path]) -> [T]",
        "getTransformedSpacedPoints": "fn(segments: number, bends?: [Path]) -> [T]",
        "getWrapPoints": "fn(oldPts: [T], path: Path) -> [T]"
      }
    },
    "Gyroscope": {
      "!type": "fn()",
      "prototype": {
        "updateMatrixWorld": "fn(force?: bool)"
      }
    },
    "PathActions": "number",
    "PathAction": {
      "action": "PathActions",
      "args": "?"
    },
    "Path": {
      "!type": "fn(points?: [Vector2])",
      "prototype": {
        "actions": "[PathAction]",
        "fromPoints": "fn(vectors: [Vector2])",
        "moveTo": "fn(x: number, y: number)",
        "lineTo": "fn(x: number, y: number)",
        "quadraticCurveTo": "fn(aCPx: number, aCPy: number, aX: number, aY: number)",
        "bezierCurveTo": "fn(aCP1x: number, aCP1y: number, aCP2x: number, aCP2y: number, aX: number, aY: number)",
        "splineThru": "fn(pts: [Vector2])",
        "arc": "fn(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool)",
        "absarc": "fn(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool)",
        "ellipse": "fn(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool)",
        "absellipse": "fn(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool)",
        "getSpacedPoints": "fn(divisions?: number, closedPath?: bool) -> [Vector2]",
        "getPoints": "fn(divisions?: number, closedPath?: bool) -> [Vector2]",
        "toShapes": "fn() -> [Shape]"
      }
    },
    "Shape": {
      "!type": "fn(points?: [Vector2])",
      "prototype": {
        "holes": "[Path]",
        "extrude": "fn(options?: ?) -> ExtrudeGeometry",
        "makeGeometry": "fn(options?: ?) -> ShapeGeometry",
        "getPointsHoles": "fn(divisions: number) -> [[Vector2]]",
        "getSpacedPointsHoles": "fn(divisions: number) -> [[Vector2]]",
        "extractAllPoints": "fn(divisions: number) -> ret4",
        "extractPoints": "fn(divisions: number) -> [Vector2]",
        "extractAllSpacedPoints": "fn(divisions: Vector2) -> ret5"
      }
    },
    "ArcCurve": {
      "!type": "fn(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool)",
      "prototype": {}
    },
    "ClosedSplineCurve3": {
      "!type": "fn(points?: [Vector3])",
      "prototype": {
        "points": "[Vector3]"
      }
    },
    "CubicBezierCurve": {
      "!type": "fn(v0: Vector2, v1: Vector2, v2: Vector2, v3: Vector2)",
      "prototype": {
        "v0": "Vector2",
        "v1": "Vector2",
        "v2": "Vector2",
        "v3": "Vector2"
      }
    },
    "CubicBezierCurve3": {
      "!type": "fn(v0: Vector3, v1: Vector3, v2: Vector3, v3: Vector3)",
      "prototype": {
        "v0": "Vector3",
        "v1": "Vector3",
        "v2": "Vector3",
        "v3": "Vector3"
      }
    },
    "EllipseCurve": {
      "!type": "fn(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool)",
      "prototype": {
        "aX": "number",
        "aY": "number",
        "xRadius": "number",
        "yRadius": "number",
        "aStartAngle": "number",
        "aEndAngle": "number",
        "aClockwise": "bool"
      }
    },
    "LineCurve": {
      "!type": "fn(v1: Vector2, v2: Vector2)",
      "prototype": {
        "v1": "Vector2",
        "v2": "Vector2"
      }
    },
    "LineCurve3": {
      "!type": "fn(v1: Vector3, v2: Vector3)",
      "prototype": {
        "v1": "Vector3",
        "v2": "Vector3"
      }
    },
    "QuadraticBezierCurve": {
      "!type": "fn(v0: Vector2, v1: Vector2, v2: Vector2)",
      "prototype": {
        "v0": "Vector2",
        "v1": "Vector2",
        "v2": "Vector2"
      }
    },
    "QuadraticBezierCurve3": {
      "!type": "fn(v0: Vector3, v1: Vector3, v2: Vector3)",
      "prototype": {
        "v0": "Vector3",
        "v1": "Vector3",
        "v2": "Vector3"
      }
    },
    "SplineCurve": {
      "!type": "fn(points?: [Vector2])",
      "prototype": {
        "points": "[Vector2]"
      }
    },
    "SplineCurve3": {
      "!type": "fn(points?: [Vector3])",
      "prototype": {
        "points": "[Vector3]"
      }
    },
    "BoxGeometry": {
      "!type": "fn(width: number, height: number, depth: number, widthSegments?: number, heightSegments?: number, depthSegments?: number)",
      "prototype": {
        "parameters": {
          "width": "number",
          "height": "number",
          "depth": "number",
          "widthSegments": "number",
          "heightSegments": "number",
          "depthSegments": "number"
        }
      }
    },
    "CircleGeometry": {
      "!type": "fn(radius?: number, segments?: number, thetaStart?: number, thetaLength?: number)",
      "prototype": {
        "parameters": {
          "radius": "number",
          "segments": "number",
          "thetaStart": "number",
          "thetaLength": "number"
        }
      }
    },
    "CubeGeometry": {
      "prototype": {}
    },
    "CylinderGeometry": {
      "!type": "fn(radiusTop?: number, radiusBottom?: number, height?: number, radiusSegments?: number, heightSegments?: number, openEnded?: bool, thetaStart?: number, thetaLength?: number)",
      "prototype": {
        "parameters": {
          "radiusTop": "number",
          "radiusBottom": "number",
          "height": "number",
          "radialSegments": "number",
          "heightSegments": "number",
          "openEnded": "bool",
          "thetaStart": "number",
          "thetaLength": "number"
        }
      }
    },
    "DodecahedronGeometry": {
      "!type": "fn(radius: number, detail: number)",
      "prototype": {
        "parameters": {
          "radius": "number",
          "detail": "number"
        }
      }
    },
    "ExtrudeGeometry": {
      "!type": "fn(shape?: Shape, options?: ?)",
      "prototype": {
        "WorldUVGenerator": {
          "generateTopUV": "fn(geometry: Geometry, indexA: number, indexB: number, indexC: number) -> [Vector2]",
          "generateSideWallUV": "fn(geometry: Geometry, indexA: number, indexB: number, indexC: number, indexD: number) -> [Vector2]"
        },
        "addShapeList": "fn(shapes: [Shape], options?: ?)",
        "addShape": "fn(shape: Shape, options?: ?)"
      }
    },
    "IcosahedronGeometry": {
      "!type": "fn(radius: number, detail: number)",
      "prototype": {}
    },
    "LatheGeometry": {
      "!type": "fn(points: [Vector3], segments?: number, phiStart?: number, phiLength?: number)",
      "prototype": {
        "parameters": {
          "points": "[Vector3]",
          "segments": "number",
          "phiStart": "number",
          "phiLength": "number"
        }
      }
    },
    "OctahedronGeometry": {
      "!type": "fn(radius: number, detail: number)",
      "prototype": {}
    },
    "ParametricGeometry": {
      "!type": "fn(func: fn(u: number, v: number), slices: number, stacks: number)",
      "prototype": {
        "parameters": {
          "func": "fn(u: number, v: number)",
          "slices": "number",
          "stacks": "number"
        }
      }
    },
    "PlaneBufferGeometry": {
      "!type": "fn(width: number, height: number, widthSegments?: number, heightSegments?: number)",
      "prototype": {
        "parameters": {
          "width": "number",
          "height": "number",
          "widthSegments": "number",
          "heightSegments": "number"
        }
      }
    },
    "PlaneGeometry": {
      "!type": "fn(width: number, height: number, widthSegments?: number, heightSegments?: number)",
      "prototype": {
        "parameters": {
          "width": "number",
          "height": "number",
          "widthSegments": "number",
          "heightSegments": "number"
        }
      }
    },
    "PolyhedronGeometry": {
      "!type": "fn(vertices: [Vector3], faces: [Face3], radius?: number, detail?: number)",
      "prototype": {
        "parameters": {
          "vertices": "[Vector3]",
          "faces": "[Face3]",
          "radius": "number",
          "detail": "number"
        }
      }
    },
    "RingGeometry": {
      "!type": "fn(innerRadius?: number, outerRadius?: number, thetaSegments?: number, phiSegments?: number, thetaStart?: number, thetaLength?: number)",
      "prototype": {
        "parameters": {
          "innerRadius": "number",
          "outerRadius": "number",
          "thetaSegments": "number",
          "phiSegments": "number",
          "thetaStart": "number",
          "thetaLength": "number"
        }
      }
    },
    "ShapeGeometry": {
      "!type": "fn(shape: Shape, options?: ?)",
      "prototype": {
        "addShapeList": "fn(shapes: [Shape], options: ?) -> ShapeGeometry",
        "addShape": "fn(shape: Shape, options?: ?)"
      }
    },
    "SphereGeometry": {
      "!type": "fn(radius: number, widthSegments?: number, heightSegments?: number, phiStart?: number, phiLength?: number, thetaStart?: number, thetaLength?: number)",
      "prototype": {
        "parameters": {
          "radius": "number",
          "widthSegments": "number",
          "heightSegments": "number",
          "phiStart": "number",
          "phiLength": "number",
          "thetaStart": "number",
          "thetaLength": "number"
        }
      }
    },
    "TetrahedronGeometry": {
      "!type": "fn(radius?: number, detail?: number)",
      "prototype": {}
    },
    "TextGeometryParameters": {
      "size": "number",
      "height": "number",
      "curveSegments": "number",
      "font": "string",
      "weight": "string",
      "style": "string",
      "bevelEnabled": "bool",
      "bevelThickness": "number",
      "bevelSize": "number"
    },
    "TextGeometry": {
      "!type": "fn(text: string, TextGeometryParameters?: TextGeometryParameters)",
      "prototype": {}
    },
    "TorusGeometry": {
      "!type": "fn(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, arc?: number)",
      "prototype": {
        "parameters": {
          "radius": "number",
          "tube": "number",
          "radialSegments": "number",
          "tubularSegments": "number",
          "arc": "number"
        }
      }
    },
    "TorusKnotGeometry": {
      "!type": "fn(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, p?: number, q?: number, heightScale?: number)",
      "prototype": {
        "parameters": {
          "radius": "number",
          "tube": "number",
          "radialSegments": "number",
          "tubularSegments": "number",
          "p": "number",
          "q": "number",
          "heightScale": "number"
        }
      }
    },
    "TubeGeometry": {
      "!type": "fn(path: Path, segments?: number, radius?: number, radiusSegments?: number, closed?: bool, taper?: fn(u: number))",
      "NoTaper": "fn(u?: number) -> number",
      "SinusoidalTaper": "fn(u: number) -> number",
      "FrenetFrames": "fn(path: Path, segments: number, closed: bool)",
      "prototype": {
        "parameters": {
          "path": "Path",
          "segments": "number",
          "radius": "number",
          "radialSegments": "number",
          "closed": "bool",
          "taper": "fn(u: number)"
        },
        "tangents": "[Vector3]",
        "normals": "[Vector3]",
        "binormals": "[Vector3]"
      }
    },
    "ArrowHelper": {
      "!type": "fn(dir: Vector3, origin?: Vector3, length?: number, hex?: number, headLength?: number, headWidth?: number)",
      "prototype": {
        "line": "Line",
        "cone": "Mesh",
        "setDirection": "fn(dir: Vector3)",
        "setLength": "fn(length: number, headLength?: number, headWidth?: number)",
        "setColor": "fn(hex: number)"
      }
    },
    "AxisHelper": {
      "!type": "fn(size?: number)",
      "prototype": {}
    },
    "BoundingBoxHelper": {
      "!type": "fn(object: Object3D, hex?: number)",
      "prototype": {
        "object": "Object3D",
        "box": "[Box3]",
        "update": "fn()"
      }
    },
    "BoxHelper": {
      "!type": "fn(object?: Object3D)",
      "prototype": {
        "update": "fn(object?: Object3D)"
      }
    },
    "CameraHelper": {
      "!type": "fn(camera: Camera)",
      "prototype": {
        "camera": "Camera",
        "pointMap": {},
        "update": "fn()"
      }
    },
    "DirectionalLightHelper": {
      "!type": "fn(light: Light, size?: number)",
      "prototype": {
        "light": "Light",
        "lightPlane": "Line",
        "targetLine": "Line",
        "dispose": "fn()",
        "update": "fn()"
      }
    },
    "EdgesHelper": {
      "!type": "fn(object: Object3D, hex?: number)",
      "prototype": {}
    },
    "FaceNormalsHelper": {
      "!type": "fn(object: Object3D, size?: number, hex?: number, linewidth?: number)",
      "prototype": {
        "object": "Object3D",
        "size": "number",
        "normalMatrix": "Matrix3",
        "update": "fn(object?: Object3D)"
      }
    },
    "GridHelper": {
      "!type": "fn(size: number, step: number)",
      "prototype": {
        "color1": "Color",
        "color2": "Color",
        "setColors": "fn(colorCenterLine: number, colorGrid: number)"
      }
    },
    "HemisphereLightHelper": {
      "!type": "fn(light: Light, sphereSize: number, arrowLength: number, domeSize: number)",
      "prototype": {
        "light": "Light",
        "colors": "[Color]",
        "lightSphere": "Mesh",
        "dispose": "fn()",
        "update": "fn()"
      }
    },
    "PointLightHelper": {
      "!type": "fn(light: Light, sphereSize: number)",
      "prototype": {
        "light": "Light",
        "dispose": "fn()",
        "update": "fn()"
      }
    },
    "SkeletonHelper": {
      "!type": "fn(bone: Object3D)",
      "prototype": {
        "bones": "[Bone]",
        "root": "Object3D",
        "getBoneList": "fn(object: Object3D) -> [Bone]",
        "update": "fn()"
      }
    },
    "SpotLightHelper": {
      "!type": "fn(light: Light, sphereSize: number, arrowLength: number)",
      "prototype": {
        "light": "Light",
        "cone": "Mesh",
        "dispose": "fn()",
        "update": "fn()"
      }
    },
    "VertexNormalsHelper": {
      "!type": "fn(object: Object3D, size?: number, hex?: number, linewidth?: number)",
      "prototype": {
        "object": "Object3D",
        "size": "number",
        "normalMatrix": "Matrix3",
        "update": "fn(object?: Object3D)"
      }
    },
    "VertexTangentsHelper": {
      "!type": "fn(object: Object3D, size?: number, hex?: number, linewidth?: number)",
      "prototype": {
        "object": "Object3D",
        "size": "number",
        "update": "fn(object?: Object3D)"
      }
    },
    "WireframeHelper": {
      "!type": "fn(object: Object3D, hex?: number)",
      "prototype": {}
    },
    "ImmediateRenderObject": {
      "!type": "fn()",
      "prototype": {
        "render": "fn(renderCallback: Function)"
      }
    },
    "MorphBlendMeshAnimation": {
      "startFrame": "number",
      "endFrame": "number",
      "length": "number",
      "fps": "number",
      "duration": "number",
      "lastFrame": "number",
      "currentFrame": "number",
      "active": "bool",
      "time": "number",
      "direction": "number",
      "weight": "number",
      "directionBackwards": "bool",
      "mirroredLoop": "bool"
    },
    "MorphBlendMesh": {
      "!type": "fn(geometry: Geometry, material: Material)",
      "prototype": {
        "animationsMap": {},
        "animationsList": "[MorphBlendMeshAnimation]",
        "createAnimation": "fn(name: string, start: number, end: number, fps: number)",
        "autoCreateAnimations": "fn(fps: number)",
        "setAnimationDirectionForward": "fn(name: string)",
        "setAnimationDirectionBackward": "fn(name: string)",
        "setAnimationFPS": "fn(name: string, fps: number)",
        "setAnimationDuration": "fn(name: string, duration: number)",
        "setAnimationWeight": "fn(name: string, weight: number)",
        "setAnimationTime": "fn(name: string, time: number)",
        "getAnimationTime": "fn(name: string) -> number",
        "getAnimationDuration": "fn(name: string) -> number",
        "playAnimation": "fn(name: string)",
        "stopAnimation": "fn(name: string)",
        "update": "fn(delta: number)"
      }
    }
  },
  "'three'": "THREE",
  "!name": "three.d.ts",
  "!define": {
    "1": {
      "start": "number",
      "count": "number",
      "index": "number"
    },
    "": {
      "start": "number",
      "count": "number",
      "index": "number"
    },
    "ret": {
      "geometry": "Geometry",
      "materials": "[Material]"
    },
    "ret1": {
      "chunks": "[number]",
      "total": "number"
    },
    "ret2": {
      "paths": "[Path]",
      "offset": "number"
    },
    "ret3": {
      "offset": "number",
      "path": "Path"
    },
    "ret4": {
      "shape": "[Vector2]",
      "holes": "[[Vector2]]"
    },
    "ret5": {
      "shape": "[Vector2]",
      "holes": "[[Vector2]]"
    }
  }
}
