{
  "ErrorCallback": {},
  "AsyncResultsCallback": {},
  "AsyncResultCallback": {},
  "AsyncTimesCallback": {},
  "AsyncIterator": {},
  "AsyncResultIterator": {},
  "AsyncMemoIterator": {},
  "AsyncWorker": {},
  "AsyncQueue": {
    "length": "fn() -> number",
    "concurrency": "number",
    "started": "bool",
    "paused": "bool",
    "push": "fn(task: T, callback?: ?)",
    "unshift": "fn(task: T, callback?: ?)",
    "saturated": "fn()",
    "empty": "fn()",
    "drain": "fn()",
    "running": "fn() -> number",
    "idle": "fn() -> bool",
    "pause": "fn()",
    "resume": "fn()",
    "kill": "fn()"
  },
  "AsyncPriorityQueue": {
    "length": "fn() -> number",
    "concurrency": "number",
    "started": "bool",
    "paused": "bool",
    "push": "fn(task: T, priority: number, callback?: ?)",
    "saturated": "fn()",
    "empty": "fn()",
    "drain": "fn()",
    "running": "fn() -> number",
    "idle": "fn() -> bool",
    "pause": "fn()",
    "resume": "fn()",
    "kill": "fn()"
  },
  "Async": {
    "each": "fn(arr: [T], iterator: ?, callback: ErrorCallback)",
    "eachSeries": "fn(arr: [T], iterator: ?, callback: ErrorCallback)",
    "eachLimit": "fn(arr: [T], limit: number, iterator: ?, callback: ErrorCallback)",
    "map": "fn(arr: [T], iterator: ?, callback: ?) -> ?",
    "mapSeries": "fn(arr: [T], iterator: ?, callback: ?) -> ?",
    "mapLimit": "fn(arr: [T], limit: number, iterator: ?, callback: ?) -> ?",
    "filter": "fn(arr: [T], iterator: ?, callback: fn(results: [T])) -> ?",
    "select": "fn(arr: [T], iterator: ?, callback: fn(results: [T])) -> ?",
    "filterSeries": "fn(arr: [T], iterator: ?, callback: fn(results: [T])) -> ?",
    "selectSeries": "fn(arr: [T], iterator: ?, callback: fn(results: [T])) -> ?",
    "reject": "fn(arr: [T], iterator: ?, callback: fn(results: [T])) -> ?",
    "rejectSeries": "fn(arr: [T], iterator: ?, callback: fn(results: [T])) -> ?",
    "reduce": "fn(arr: [T], memo: R, iterator: ?, callback: ?) -> ?",
    "inject": "fn(arr: [T], memo: R, iterator: ?, callback: ?) -> ?",
    "foldl": "fn(arr: [T], memo: R, iterator: ?, callback: ?) -> ?",
    "reduceRight": "fn(arr: [T], memo: R, iterator: ?, callback: ?) -> ?",
    "foldr": "fn(arr: [T], memo: R, iterator: ?, callback: ?) -> ?",
    "detect": "fn(arr: [T], iterator: ?, callback: ?) -> ?",
    "detectSeries": "fn(arr: [T], iterator: ?, callback: ?) -> ?",
    "sortBy": "fn(arr: [T], iterator: ?, callback: ?) -> ?",
    "some": "fn(arr: [T], iterator: ?, callback: ?) -> ?",
    "any": "fn(arr: [T], iterator: ?, callback: ?) -> ?",
    "every": "fn(arr: [T], iterator: ?, callback: fn(result: bool)) -> ?",
    "all": "fn(arr: [T], iterator: ?, callback: fn(result: bool)) -> ?",
    "concat": "fn(arr: [T], iterator: ?, callback: ?) -> ?",
    "concatSeries": "fn(arr: [T], iterator: ?, callback: ?) -> ?",
    "series": "fn(tasks: [T], callback?: ?)",
    "parallel": "fn(tasks: [T], callback?: ?)",
    "parallelLimit": "fn(tasks: [T], limit: number, callback?: ?)",
    "whilst": "fn(test: Function, fn: Function, callback: Function)",
    "until": "fn(test: Function, fn: Function, callback: Function)",
    "waterfall": "fn(tasks: [T], callback?: ?)",
    "queue": "fn(worker: ?, concurrency: number) -> ?",
    "priorityQueue": "fn(worker: ?, concurrency: number) -> ?",
    "auto": "fn(tasks: ?, callback?: ?)",
    "iterator": "fn(tasks: [Function]) -> Function",
    "apply": "fn(fn: Function, arguments: [?])",
    "nextTick": "fn(callback: Function)",
    "times": "fn(n: number, callback: ?)",
    "timesSeries": "fn(n: number, callback: ?)",
    "memoize": "fn(fn: Function, hasher?: Function) -> Function",
    "unmemoize": "fn(fn: Function) -> Function",
    "log": "fn(fn: Function, arguments: [?])",
    "dir": "fn(fn: Function, arguments: [?])",
    "noConflict": "fn() -> Async"
  },
  "async": "Async",
  "!name": "async.d.ts"
}
